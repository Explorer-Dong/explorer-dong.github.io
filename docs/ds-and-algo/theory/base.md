---
title: 基础
---

基础因人而异，下面罗列的是个人认为相对基础的知识点。只有熟练掌握了以下基础算法，才有可能理解更复杂的算法从而解出更高难度的问题。

## 贪心

贪心算法其实并不简单，很多时候需要敢想敢猜并且证明往往并不容易，但因为这种方法套路不多，就放在第一个基础算法部分展开。

贪心考虑的是局部最优，即每次做决策时都是选当前的局部最优解。当然，如果可以举出贪心后的反例，就可以考虑使用动态规划等其他全局性的策略来解决问题了。

对于贪心问题的证明，我总结出了两个证明方法。如下：

- 反证法：假设取一种方案比贪心方案更好，得出相反的结论；
- 边界法：从边界开始考虑，因为满足边界条件更加容易枚举，从而进行后续的贪心。

## 前缀和与差分

前缀和与差分是两类算法，但由于是相辅相成的关系，故将其列在一起。两种算法的适用场景如下：

- 前缀和算法适用于「频繁求子数组之和、不频繁修改数组元素」的场景；
- 差分算法适用于「频繁增减子数组元素值、不频繁求数组元素」的场景。

更精简地说：

- 前缀和算法适用于「频繁区间查询、不频繁单点修改」的场景；
- 差分算法适用于「频繁区间修改、不频繁单点查询」的场景。

!!! tip

    如果需要同时频繁地「区间修改、区间查询」，可以使用进阶数据结构诸如 [树状数组](./ds.md/#树状数组) 或 [线段树](./ds.md/#线段树) 来实现。

### 前缀和算法

为了学习差分算法，我们有必要先学习前缀和算法。具体地，对于一个长度为 $n$ 的数组 $a$，我们定义 $s_i$ 表示：
$$
s_i=\sum_{j=0}^{i}a_j
$$

那么当进行区间查询求解数组中下标在闭区间 $[p,q]$ 中的元素和时，只需要 $s_q-s_{p-1}$ 地 $O(1)$ 计算出来即可。我们称 $s$ 为数组 $a$ 的前缀和数组。为了维护出 $s$，我们采用 [递推](./dp.md) 算法。即：

$$
s_i=
\begin{cases}
a_0,&i=0\\
s_{i-1}+a_i,&i\ge1
\end{cases}
$$

### 差分算法

为了实现给数组中下标在闭区间 $[i,j]$ 中的元素 $s_{i\sim j}$ 同时增加 $x$，我们可以借助前缀和算法的思路来实现。具体地，仍然记原始数组为 $a$，前缀和数组为 $s$，如果将 $a_i+x$ 同时 $a_{j+1}-x$，那么在维护前缀和数组 $s$ 时，$s_{i\sim j}$ 中的每一个元素就都增加了 $x$。

利用上述思路，我们可以将待操作的数组看做已经维护好的前缀和数组 $s$，并利用 $a_i=s_i-s_{i-1}$ 计算出差分数组 $a$，后续如果需要频繁地给待操作数组进行区间修改，只需要 $O(1)$ 地修改差分数组的两个边界即可。

综上所述：

- 前缀和算法高效的前提是数组元素尽可能保持不变，如果需要频繁变动数组元素，利用前缀和算法进行区间求和就不合适了；
- 差分算法高效的前提是不需要频繁的索引数组元素，如果需要频繁索引数组元素，利用差分算法进行区间修改就不合适了。

## 二分

二分本质上就是对「具有单调性的序列」进行加速查询的操作。假设有一个含有 $n$ 个元素的序列 $a$，其属性 $attr$ 是单调递增的。现在想要查询属性 $attr$ 取值为 $tar$ 的元素在序列中的位置。显然我们可以遍历一边序列 $a$ 并逐个比较即可，但由于属性 $attr$ 是单调的，在下标范围为 $[l,r]$ 的序列中查找时，只需要不断比较 $tar$ 和 $a_{(l+r)/2}$ 的值即可，具体地：

- 如果 $tar < a_{(l+r)/2}$，那么答案一定在 $[l,(l+r)/2]$ 中；
- 如果 $tar > a_{(l+r)/2}$，那么答案一定在 $[(l+r)/2,r]$ 中；
- 如果 $tar = a_{(l+r)/2}$，那么答案就是 $(l+r)/2$。

## 搜索

## 分治

分治的三个步骤：

1. divide。将待处理的问题划分为多个互斥的子问题；
2. conquer。递归处理子问题；
3. combine。归并子问题的处理结果得到最终的结果。

## 排序

很多教程或教材都喜欢把这一块单独拿出来讲，可能因为排序算法是很多算法策略的具体实现。但这里有一些算法并不适合新手学习，如果遇到不怎么懂的排序策略，请先跳转到对应的知识点进行学习，之后再过来学习对应的排序算法会好很多。此处只讨论「快速排序」、「归并排序」和「堆排序」三种较为复杂的排序算法，其余排序算法请自行查阅。

首先讲一个排序衍生出的概念：稳定性。如果一个排序算法，在对所有元素排序后，原来相同关键字的顺序保持不变，则称该排序算法是稳定的，反之如果相同关键字的顺序改变了就称该排序算法是不稳定的。

### 快速排序

这是一种不稳定的排序算法，核心思想是 **分治**。具体地，以升序为例，如果一个序列是有序的，那么对于该序列中的每一个元素，其左边所有元素都应该比右边所有元素小。基于该先验，我们就有了快速排序算法：

1. 选择序列中任意一个元素作为基准；
2. 基于该基准，扫描一遍序列将比基准小的元素排在基准的左边，比基准大的元素排在基准的右边；
3. 递归左右两边的序列直到序列只有 1 个元素为止。

在计算时间复杂度时，我们可以将分治的逻辑想象成一棵二叉树，对于二叉树的每一层都会有 $O(n)$ 的遍历开销，而二叉树的层数平均有 $O(\log n)$ 层，因此排序的时间复杂度就是 $O(n\log n)$。当然如果每次选择的基准刚好是所在序列的最值，就会导致二叉树的层数退化到 $O(n)$，但一般来说不会这么极端。

快速排序 C++ 示例代码：

```c++
vector<int> a = {3, 1, 4, 2, 5};  // 待排序数组

void quick_sort(int l, int r) {
    if (l >= r) return;

    // conquer
    int i = l - 1, j = r + 1, x = a[(l + r) >> 1];
    while (i < j) {
        while (a[++i] < x);
        while (a[--j] > x);
        if (i < j) swap(a[i], a[j]);
    }

    // divide
    quick_sort(l, j);
    quick_sort(j + 1, r);
}

quick_sort(0, a.size() - 1);  // 调用示例
```

### 归并排序

这是一种稳定的排序算法，核心思想同样是分治且符合标准的三步分治策略。同样以升序为例，如果两个有序序列都是升序或都是降序，那么可以双指针扫描一遍从而 $O(n)$ 地合并这两个序列为一个有序序列。基于该先验，我们就有了归并排序算法：

1. 将序列等分为左右两部分；
2. 分治左右两部分使得左右两部分都是升序或都是降序；
3. 合并左右两个有序序列。

时间复杂度的计算与快速排序类似，只不过这里的分治递归二叉树一定是 $O(\log n)$ 层，那么时间复杂度就是稳定的 $O(n \log n)$。

归并排序 C++ 示例代码：

```c++
vector<int> a = {3, 1, 4, 2, 5};  // 待排序数组
vector<int> t(a.size(), 0);       // 临时数组

void merge_sort(int l, int r) {
    if (l >= r) return;

    // divide
    int mid = (l + r) >> 1;

    // conquer
    merge_sort(l, mid), merge_sort(mid + 1, r);

    // combine
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (a[i] < a[j]) t[k++] = a[i++];
        else t[k++] = a[j++];
        cnt++;
    }
    while (i <= mid) t[k++] = a[i++];
    while (j <= r) t[k++] = a[j++];

    for (i = l, j = 0; i <= r; i++) a[i] = t[j++];
};

merge_sort(0, a.size() - 1);  // 调用示例
```

### 堆排序

这是一种不稳定的排序算法。其实就是利用了堆结构及其支持的操作，每次输出堆顶然后维护堆结构即可实现堆排序。因此如果掌握了  这一数据结构，堆排序算法就跃然纸上了：

1. 将给定的序列维护成堆结构；
2. 每次输出堆顶并重新维护堆结构即可。

为了计算堆排序算法的时间复杂度，我们分别考虑算法的两步中对应的计算开销：

1. 对于维护堆结构。可以利用完全二叉树的性质，对于一个大小为 $n$ 的完全二叉树，其后 $n/2$ 个元素都一定满足堆的定义，因此只需要对前 $n/2$ 个元素执行 `down()` 操作即可，经过简单的错位相减运算可以得出该操作是 $O(n)$ 的；
2. 对于输出堆顶并重新维护堆结构。输出是 $O(1)$ 的，重新维护堆结构其实就是删除完全二叉树的根结点，这里有一个技巧，就是将数组中的最后一个树中元素替换掉数组中的第一个元素（即根结点），然后 `down()` 这个新的根结点即可实现重新维护出一个堆结构，这样对于 $n$ 个元素，每次都要 $O(\log n)$ 地 `down()` 一次，那么就是 $O(n\log n)$。

最终的时间复杂度就是 $O(n\log n)$。

堆排序 C++ 示例代码（下标从 0 开始）：

=== "非递归"

    ```c++
    void down(int u) {
        int l = 2 * u + 1;
        int r = 2 * u + 2;
        int t = u;
        
        while (true) {
            if (l <= last && heap[u] > heap[l]) {
                t = l;
            }
            if (r <= last && heap[u] > heap[r] && heap[r] < heap[l]) {
                t = r;
            }
            
            if (t != u) {
                swap(heap[t], heap[u]);
                down(t);
                u = t;
                l = 2 * u + 1;
                r = 2 * u + 2;
            } else {
                break;
            }
        }
    }
    
    void up(int u) {
        int fa = (u - 1) / 2;
        
        while (fa >= 0 && heap[fa] > heap[u]) {
            swap(heap[fa], heap[u]);
            u = fa;
            fa = (u - 1) / 2;
        }
    }
    ```

=== "递归"

    ```c++
    void down(int u) {
        int l = 2 * u + 1;
        int r = 2 * u + 2;
        
        int t = u;
        if (l <= last && heap[u] > heap[l]) {
            t = l;
        }
        if (r <= last && heap[u] > heap[r] && heap[r] < heap[l]) {
            t = r;
        }
        
        if (t != u) {
            swap(heap[t], heap[u]);
            down(t);
        }
    }
    
    void up(int u) {
        int fa = (u - 1) / 2;
        
        if (fa >= 0 && heap[fa] > heap[u]) {
            swap(heap[fa], heap[u]);
            up(fa);
        }
    }
    ```

=== "两种初始化"

    ```c++
    // 从下往上
    for (int i = n / 2; i >= 0; i--) {
        down(i);
    }
    ```
    
    ```c++
    // 从上往下
    for (int i = 1; i < n; i++) {
        up(i);
    }
    ```

=== "完整代码"

    ```c++
    #include <iostream>
    
    using namespace std;
    
    int n, m;
    int heap[100010];
    int last;
    
    void down(int u) {
        int l = 2 * u + 1;
        int r = 2 * u + 2;
        
        int t = u;
        if (l <= last && heap[u] > heap[l]) {
            t = l;
        }
        if (r <= last && heap[u] > heap[r] && heap[r] < heap[l]) {
            t = r;
        }
        
        if (t != u) {
            swap(heap[t], heap[u]);
            down(t);
        }
    }
    
    void up(int u) {
        int fa = (u - 1) / 2;
        
        if (fa >= 0 && heap[fa] > heap[u]) {
            swap(heap[fa], heap[u]);
            up(fa);
        }
    }
    
    int main() {
        cin >> n >> m;
        for (int i = 0; i < n; i++) {
            cin >> heap[i];
        }
        last = n - 1;
        
        // 初始化堆结构
        for (int i = n / 2; i >= 0; i--) {
            down(i);
        }
        
        // 输出堆顶 + 重新维护堆结构
        for (int i = 0; i < m; i++) {
            cout << heap[0] << " ";
            heap[0] = heap[last--];
            down(0);
        }
        
        return 0;
    }
    ```
