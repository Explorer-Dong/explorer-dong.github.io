---
title: æ•°æ®ç»“æ„
---

æ•°æ®ç»“æ„ç”±ã€Œæ•°æ®ã€å’Œã€Œç»“æ„ã€ä¸¤éƒ¨åˆ†ç»„æˆã€‚æˆ‘ä»¬ä¸»è¦è®¨è®ºçš„æ˜¯åè€…ï¼Œå³ç»“æ„éƒ¨åˆ†ã€‚æŒ‰ç…§é€»è¾‘ç»“æ„å¯ä»¥å°†å„ç§æ•°æ®ç»“æœåˆ†ç±»ä¸ºã€Œçº¿æ€§ç»“æ„ã€å’Œã€Œéçº¿æ€§ç»“æ„ã€ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š

![çº¿æ€§æ•°æ®ç»“æ„ vs éçº¿æ€§æ•°æ®ç»“æ„](https://cdn.dwj601.cn/images/202408301527018.png)

/// caption
çº¿æ€§æ•°æ®ç»“æ„ vs éçº¿æ€§æ•°æ®ç»“æ„
///

åœ¨é¢å¯¹ä¸€ä¸ªå®é™…é—®é¢˜æ—¶ï¼Œæˆ‘ä»¬å¾€å¾€éœ€è¦è€ƒè™‘ä¸¤ä¸ªé—®é¢˜ï¼šéœ€è¦å­˜å‚¨ä»€ä¹ˆä¿¡æ¯ï¼Ÿä»¥åŠä¿¡æ¯ä¹‹é—´çš„ç»„ç»‡æ–¹å¼æ˜¯ä»€ä¹ˆï¼Ÿä¸€èˆ¬è€Œè¨€ï¼Œå­˜å‚¨çš„éƒ½æ˜¯æ•°å€¼æ•°æ®æˆ–è€…æ•°æ®ä¹‹é—´çš„å…³ç³»ï¼Œç»„ç»‡æ–¹å¼æœ‰çº¿æ€§ç»“æ„ã€æ ‘å½¢ç»“æ„ã€å›¾ç»“æ„å…±ä¸‰ç§ï¼ˆæœ‰äº›æ•™æä¼šå•ç‹¬æŠŠé›†åˆæ‹¿å‡ºæ¥ï¼Œä½†ç”±äºé›†åˆçš„é€»è¾‘ä¸€èˆ¬éƒ½é€šè¿‡æ ‘æˆ–å›¾æ¥å®ç°ï¼Œå› æ­¤è¿™é‡Œä¸å•ç‹¬ç½—åˆ—ï¼‰ã€‚

ç®—æ³•çš„äº”å¤§ç‰¹æ€§ã€‚1ï¼‰æ­£ç¡®æ€§ï¼›2ï¼‰å¥å£®æ€§ï¼ˆé²æ£’æ€§ï¼‰ï¼›3ï¼‰å¯è¯»æ€§ï¼›4ï¼‰å¯æ‰©å±•æ€§ï¼›5ï¼‰é«˜æ•ˆç‡ã€‚å…¶ä¸­é«˜æ•ˆç‡ä¸­åˆå¼•å‡ºäº†å¤æ‚åº¦çš„å¤§ $O$ è¡¨ç¤ºæ³•ï¼Œå…·ä½“åœ°ï¼š

- $O()$ `upper bound`ï¼šæœ€åçš„æ—¶é—´å¤æ‚åº¦ï¼›
- $\Omega()$ `lower bound`ï¼šæœ€å¥½çš„æ—¶é—´å¤æ‚åº¦ï¼›
- $\Theta()$ `average bound`ï¼šå¹³å‡æ—¶é—´å¤æ‚åº¦ã€‚

## é“¾è¡¨

æœ¬èŠ‚åŸæœ¬å«åšã€Œçº¿æ€§è¡¨ã€ï¼Œä½†æ˜¯è€ƒè™‘åˆ°é¡ºåºå­˜å‚¨ç»“æ„çš„çº¿æ€§è¡¨å°±æ˜¯æ•°ç»„ï¼Œå› æ­¤è¿™é‡Œåªè®¨è®ºé“¾å¼å­˜å‚¨ç»“æ„çš„çº¿æ€§è¡¨ï¼Œå³é“¾è¡¨ã€‚

å¸¸è§çš„é“¾è¡¨ç»“æ„ã€‚å•é“¾è¡¨ã€å¾ªç¯é“¾è¡¨ã€åŒå‘é“¾è¡¨å…±ä¸‰ç§ã€‚ä½†æ— è®ºå“ªç§ç»“æ„ï¼Œéƒ½æ˜¯ä¸€ä¸ªå¤´ç»“ç‚¹ + ä¸€ä¸ªå°¾ç»“ç‚¹ + è‹¥å¹²ä¸­é—´ç»“ç‚¹çš„ç»“æ„ï¼Œä¸”æ¯ä¸ªç»“ç‚¹åªæœ‰ä¸€ä¸ªå‰é©±ç»“ç‚¹å’Œä¸€ä¸ªåç»§ç»“ç‚¹ã€‚

åˆå§‹åŒ–æŠ€å·§ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œä¸ºäº†ä¾¿äºç¼–ç ï¼Œéƒ½ä¼šæå‰è®¾ç½®ç©ºç»“ç‚¹ã€‚ä¾‹å¦‚å•é“¾è¡¨ä¼šè®¾ç½®ä¸€ä¸ªç©ºçš„å¤´ç»“ç‚¹ï¼Œå¾ªç¯é“¾è¡¨ä¼šè®¾ç½®ä¸€ä¸ªç©ºçš„å°¾ç»“ç‚¹ï¼ŒåŒå‘é“¾è¡¨ä¼šè®¾ç½®ä¸€ä¸ªç©ºçš„å¤´ç»“ç‚¹å’Œç©ºçš„å°¾ç»“ç‚¹ã€‚

å¸¸è§æ“ä½œã€‚å¯¹äºé“¾è¡¨è€Œè¨€ï¼Œå…¶æœ€å¤§çš„ç‰¹ç‚¹å°±æ˜¯åˆ é™¤æˆ–æ·»åŠ ç»“ç‚¹çš„å¼€é”€å¾ˆå°ï¼Œè‡³äºæŸ¥è¯¢æˆ–ä¿®æ”¹ç›´æ¥é“¾å¼éå†å³å¯ã€‚å› æ­¤æˆ‘ä»¬åº”ç†Ÿç»ƒæŒæ¡é“¾è¡¨ç»“ç‚¹çš„åˆ é™¤ä¸æ·»åŠ æ“ä½œã€‚

=== "åŒå‘é“¾è¡¨ç»“ç‚¹æ·»åŠ "

    ![æ·»åŠ ç»“ç‚¹](https://cdn.dwj601.cn/images/202406292218514.png)
    /// caption
    ///
    
    ```c++
    s->prior = p;
    s->next = p->next;
    p->next->prior = s;
    p->next = s;
    ```

=== "åŒå‘é“¾è¡¨ç»“ç‚¹åˆ é™¤"

    ![åˆ é™¤ç»“ç‚¹](https://cdn.dwj601.cn/images/202406292218515.png)
    /// caption
    ///
    
    ```c++
    p->next->prior = p->prior;
    p->prior->next = p->next;
    ```

## æ ˆ

å…ˆè¿›åå‡ºå‹çº¿æ€§æ•°æ®ç»“æ„ã€‚åˆ†ä¸ºé¡ºåºæ ˆå’Œé“¾æ ˆï¼Œé¡ºåºæ ˆå°±æ˜¯æ•°ç»„æ¨¡æ‹Ÿï¼Œé“¾æ ˆå°±ç±»ä¼¼äºå¤´æ’æ³•çš„å•é“¾è¡¨ã€‚ç”±äºç»“æ„æ¯”è¾ƒç®€å•ï¼Œå› æ­¤æˆ‘ä»¬é‡ç‚¹å…³æ³¨æ ˆçš„åº”ç”¨ã€‚

**å¡ç‰¹å…°æ•°**ã€‚å…¶å®æ˜¯ä¸€ç§åŠ¨æ€è§„åˆ’çš„ç®—æ³•æ€æƒ³ã€‚å¸¸è§çš„é‡Šä¹‰ä¸ºï¼šå½“æœ‰ $n$ ä¸ªå…ƒç´ æŒ‰ç…§æŸç§é¡ºåºå‹å…¥æ ˆä¸­ï¼Œä¸”å¯åœ¨ä»»æ„æ—¶åˆ»å¼¹å‡ºæ—¶ï¼Œæ‰€è·å¾—å¯èƒ½çš„å‡ºæ ˆåºåˆ—ä¸ªæ•°å¯ç”¨å¡ç‰¹å…°æ•°è®¡ç®—ï¼Œå³ $\frac{1}{n+1} C_{2n}^{n}$ã€‚

å®šä¹‰ $f(k)$ è¡¨ç¤ºåœ¨ç¬¬ $k$ ä¸ªæ•°æ˜¯æœ€åä¸€ä¸ªå‡ºæ ˆçš„æƒ…å†µä¸‹å‡ºæ ˆåºåˆ—çš„æ€»ä¸ªæ•°ï¼Œåˆ™ $f(k)=f(k-1)f(n-k)$ï¼Œå…¶ä¸­ $f(0)=1$ã€‚é‚£ä¹ˆå¡ç‰¹å…°æ•°çš„æ¨å¯¼å…¬å¼å°±æ˜¯ï¼š

$$
\sum_{k = 1}^{n} f(k) = \sum_{k = 1}^{n} f(k-1) f(n-k)=\frac{1}{n+1} C_{2n}^{n}
$$

**è¡¨è¾¾å¼æ±‚å€¼**ã€‚åˆ†ä¸ºå‰ç¼€ã€ä¸­ç¼€å’Œåç¼€ä¸‰ç§è¡¨è¾¾å¼ï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹æ ‘çš„ä¸€ç§éå†ã€‚å…·ä½“åœ°ï¼š

- ä¸­ç¼€è¡¨è¾¾å¼æ±‚å€¼ã€‚ã€ŒåŒæ ˆã€æ€è·¯ï¼Œç®—ç¬¦ä¼˜å…ˆæ³•ï¼š
    - é‡åˆ°æ•°å­—ï¼Œç›´æ¥å…¥æ•°æ ˆï¼›
    - é‡åˆ°ç¬¦å·ï¼š
        - å¦‚æœæ˜¯æ‹¬å·ï¼Œå·¦æ‹¬å·ç›´æ¥å…¥æ ˆï¼Œå³æ‹¬å·è¿›è¡Œè¿ç®—ç›´åˆ°é‡åˆ°å·¦æ‹¬å·ï¼›
        - å¦‚æœæ˜¯ç®—ç¬¦ï¼Œåœ¨å…¥ç®—ç¬¦æ ˆä¹‹å‰ï¼Œéœ€è¦è¿›è¡Œè¿ç®—æ“ä½œç›´åˆ°ç®—ç¬¦æ ˆé¡¶å…ƒç´ ç­‰çº§å°äºå½“å‰ç®—ç¬¦ç­‰çº§ã€‚
- ä¸­ç¼€è¡¨è¾¾å¼è½¬åç¼€è¡¨è¾¾å¼ã€‚ã€Œç®—ç¬¦æ ˆã€å³å¯ï¼Œåç¼€å…ˆé‡åˆ°å°±ç›´æ¥è®¡ç®—çš„è¿ç®—ç¬¦ $\to$ ä¸­ç¼€è¡¨è¾¾å¼éœ€è¦å…ˆç®—çš„è¿ç®—ç¬¦ï¼Œäºæ˜¯è½¬åŒ–æ€è·¯å°±æ˜¯ï¼š
    - é‡åˆ°æ•°å­—ï¼Œç›´æ¥æ„é€ åç¼€è¡¨è¾¾å¼ï¼›
    - é‡åˆ°ç®—ç¬¦ï¼š
        - å¦‚æœæ˜¯æ‹¬å·ï¼Œå·¦æ‹¬å·ç›´æ¥å…¥æ ˆï¼Œå³æ‹¬å·è¿›è¡Œåç¼€è¡¨è¾¾å¼æ„é€ ç›´åˆ°é‡åˆ°å·¦æ‹¬å·ï¼›
        - å¦‚æœæ˜¯ç®—ç¬¦ï¼Œåœ¨å…¥ç®—ç¬¦æ ˆä¹‹å‰ï¼Œéœ€è¦è¿›è¡Œåç¼€è¡¨è¾¾å¼æ„é€ æ“ä½œç›´åˆ°ç®—ç¬¦æ ˆé¡¶å…ƒç´ ç­‰çº§å°äºå½“å‰ç®—ç¬¦ç­‰çº§ã€‚
- åç¼€è¡¨è¾¾å¼æ±‚å€¼ã€‚ã€Œæ•°æ ˆã€å³å¯ï¼š
    - é‡åˆ°æ•°å­—ç›´æ¥å…¥æ•°æ ˆï¼›
    - é‡åˆ°ç®—ç¬¦ç›´æ¥è¿›è¡Œè¿ç®—ã€‚

## é˜Ÿåˆ—

å…ˆè¿›å…ˆå‡ºå‹çº¿æ€§æ•°æ®ç»“æ„ã€‚åˆ†ä¸ºé¡ºåºé˜Ÿåˆ—å’Œé“¾å¼é˜Ÿåˆ—ï¼Œé¡ºåºé˜Ÿåˆ—å°±æ˜¯æ•°ç»„æ¨¡æ‹Ÿï¼Œé“¾å¼é˜Ÿåˆ—å°±ç±»ä¼¼äºåŒå‘é“¾è¡¨ã€‚é˜Ÿåˆ—çš„ä¸€äº›åº”ç”¨å¦‚ä¸‹ï¼š

**æŠ¥æ•°é—®é¢˜**ã€‚æŠ¥åˆ° $0$ çš„å‡ºé˜Ÿï¼ŒæŠ¥åˆ° $1$ çš„é‡æ–°å…¥é˜Ÿï¼Œæ±‚è§£å‡ºé˜Ÿé¡ºåºã€‚

**æœ€çŸ­è·¯é—®é¢˜**ã€‚å¼€ä¸€ä¸ªè®°å¿†æ•°ç»„ $d[i][j]$ è¡¨ç¤ºä»èµ·ç‚¹ $(0,0)$ åˆ°ç»ˆç‚¹ $(i,j)$ ç‚¹çš„æœ€çŸ­è·¯å¾„çš„é•¿åº¦ã€‚å¯ä»¥å°†æ±‚æœ€çŸ­è·¯çœ‹åšä¸€ä¸ª **æ³¢å¿ƒæ‰©æ•£** çš„ç‰©ç†åœºæ™¯ï¼Œé˜Ÿåˆ—ä¸­çš„æ¯ä¸€ä¸ªç‚¹éƒ½å¯ä»¥ä½œä¸ºä¸€ä¸ªæ³¢å¿ƒï¼Œä»è€Œå®ç°â€œä¸¤ç‚¹ä¹‹é—´çº¿æ®µæœ€çŸ­â€çš„ç‰©ç†åœºæ™¯ã€‚è®¨è®ºå‡ ä¸ªé—®é¢˜ï¼š

- ä¸ºä»€ä¹ˆç”¨é˜Ÿåˆ—ï¼Ÿé€å±‚æœç´¢ï¼Œæ¯æ¬¡æœç´ åˆ°çš„ç‚¹å°±æ˜¯å½“å‰ç‚¹å¯ä»¥æœç´¢åˆ°çš„æœ€çŸ­çš„ç‚¹ï¼Œå…ˆæœåˆ°çš„ç‚¹å…ˆæ‰©å±•ï¼Œäºæ˜¯å°±æ˜¯é˜Ÿåˆ—çš„æ•°æ®ç»“æ„ï¼›
- ä¸ºä»€ä¹ˆæ˜¯æœ€çŸ­ï¼Ÿå¯¹äºæ¯ä¸€ä¸ªç‚¹æ¢ç´¢åˆ°çš„ç‚¹éƒ½æ˜¯æœ€çŸ­çš„ç‚¹ï¼Œæœ€ç»ˆçš„æœç´¢å‡ºæ¥çš„è·¯å¾„å°±æ˜¯æœ€çŸ­çš„è·¯å¾„ã€‚

**å¾ªç¯é˜Ÿåˆ—**ã€‚é˜Ÿåˆ—ä¸­è¡ç”Ÿå‡ºçš„å¾ªç¯é˜Ÿåˆ—æ¯”è¾ƒæœ‰æ„æ€ï¼Œè¿è¡Œé€»è¾‘é¡¾åæ€ä¹‰ä¸å†èµ˜è¿°ï¼Œæœ‰å‡ ä¸ªæ³¨æ„ç‚¹ï¼š

- è§£å†³å‡æº¢å‡ºã€‚åœ¨å…¥é˜Ÿçš„æ—¶å€™ä¸æ˜¯å•çº¯çš„æŒ‡é’ˆ `+1`ï¼Œè€Œæ˜¯ `+1` å `% MaxSize`ï¼›

- è§£å†³çœŸæº¢å‡ºã€‚å³é˜Ÿç©ºé˜Ÿæ»¡çš„å†²çªï¼Œæœ‰å¦‚ä¸‹å‡ ç§åº”å¯¹ç­–ç•¥ï¼š

    - æµªè´¹ä¸€ä¸ªå…ƒç´ ç©ºé—´å¹¶åˆ¤æ–­ `rear + 1 == head`ï¼›

    - è®¾ç½®ä¸€ä¸ªè¾…åŠ©æ ‡å¿—å˜é‡ `flag`ï¼›
    - è®¾ç½®ä¸€ä¸ªè®¡æ•°å™¨ `count`ï¼›

## å“ˆå¸Œè¡¨

å“ˆå¸Œæ˜¯ä¸€ç§åº”ç”¨æå…¶å¹¿æ³›çš„ç®—æ³•ï¼Œå…¶æ ¸å¿ƒåŠŸèƒ½ä¸ºï¼š**ç»™å®šä»»æ„ä¸€ä¸ªå¯¹è±¡ Aï¼Œèƒ½åˆ©ç”¨å“ˆå¸Œè¡¨è¿…é€Ÿæ‰¾åˆ°ä»¥ A çš„åä¹‰å­˜å‚¨çš„ç»“æœ**ã€‚å…³é”®ç‚¹å¦‚ä¸‹ï¼š

- è¿™é‡Œçš„ A å¿…é¡»æ˜¯å¯å“ˆå¸Œçš„ï¼›
- è¿™é‡Œçš„å“ˆå¸Œè¡¨å…¶å®æ˜¯ä¸€ä¸ªæ•°ç»„ï¼›
- æ‰€è°“çš„è¿…é€Ÿå…¶å®æ˜¯åˆ©ç”¨å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºè¿™ä¸ªå¯å“ˆå¸Œå¯¹è±¡ A çš„å“ˆå¸Œç ï¼ˆå°±æ˜¯ä¸€ä¸ªæ•°å­—å¯¹åº”åˆ°å“ˆå¸Œè¡¨æ•°ç»„ä¸­çš„æŸä¸€ä¸ªä¸‹æ ‡ç´¢å¼•å€¼ï¼‰ï¼Œç„¶å $O(1)$ åœ°åœ¨å“ˆå¸Œè¡¨æ•°ç»„ä¸­ç´¢å¼•å‡ºå­˜å‚¨çš„å†…å®¹ã€‚

ä¸¾ä¸ªä¾‹å­ã€‚ç°åœ¨éœ€è¦æŸ¥è¯¢å‡ºä½ è¿™å­¦æœŸç¿˜äº†å‡ æ¬¡è¯¾ï¼Œä¸€ä¸ªæœ€ç›´è§‚çš„åšæ³•å°±æ˜¯éå†æ•°æ®åº“ç„¶ååŒ¹é…ä½ çš„å­¦å·ï¼ˆå‡è®¾å­¦å·å”¯ä¸€ï¼‰ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(1)$ã€‚ä½†å¦‚æœæå‰åˆ©ç”¨å“ˆå¸Œç®—æ³•å­˜å‚¨äº†æ¯ä¸€ä¸ªå­¦å·å¯¹åº”çš„ç¿˜è¯¾æ¬¡æ•°ï¼Œé‚£ä¹ˆåœ¨è¾“å…¥ä½ çš„å­¦å·åï¼Œå°±å¯ä»¥é€šè¿‡å“ˆå¸Œå‡½æ•°è®¡ç®—å‡ºä½ å­¦å·å¯¹åº”çš„å“ˆå¸Œç ï¼Œç„¶ååœ¨å“ˆå¸Œè¡¨æ•°ç»„ä¸­ç´¢å¼•å‡ºç¿˜è¯¾çš„æ¬¡æ•°å³å¯ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(1)$ï¼Œç©ºé—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

å¤§å¤šæ•°ç¼–ç¨‹è¯­è¨€éƒ½å®ç°äº†å“ˆå¸Œçš„åŠŸèƒ½ï¼Œåªè¦å¯¹è±¡æ˜¯å¯å“ˆå¸Œçš„ï¼Œå°±å¯ä»¥åˆ©ç”¨è¯¥ç®—æ³•å®Œæˆç©ºé—´æ¢æ—¶é—´çš„æ“ä½œã€‚ä¾‹å¦‚ C++ ä¸­çš„ `unordered_map` ç±»ã€Python ä¸­çš„ `dict` ç±»ã€Java ä¸­çš„ `HashMap` ç±»ç­‰ã€‚

**å“ˆå¸Œå†²çª**ã€‚å½“ç„¶ï¼Œå“ˆå¸Œç®—æ³•æ²¡æ³•ä¿è¯ä¸åŒå¯¹è±¡çš„å“ˆå¸Œç éƒ½æ˜¯ä¸åŒçš„ï¼Œæœ‰å°æ¦‚ç‡ä¼šå‘ç”Ÿä¸åŒçš„å¯¹è±¡æ˜ å°„å‡ºäº†ç›¸åŒçš„å“ˆå¸Œç ï¼Œæ­¤æ—¶å°±å‘ç”Ÿäº†å“ˆå¸Œå†²çªã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè¦ä¹ˆä¼˜åŒ–å“ˆå¸Œå‡½æ•°ä»è€Œé™ä½å“ˆå¸Œå†²çªçš„æ¦‚ç‡ï¼Œè¦ä¹ˆä¿®æ”¹å“ˆå¸Œè¡¨çš„ä¸€ç»´æ•°ç»„ç»“æ„ï¼Œå½»åº•è§£å†³å“ˆå¸Œå†²çªã€‚æˆ‘ä»¬å…³æ³¨åè€…ï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼š

1. æ‹‰é“¾æ³• (Chaining)ã€‚æˆ‘ä»¬ä»ç„¶æ²¿ç”¨ä¸€ç»´æ•°ç»„ä½œä¸ºå“ˆå¸Œè¡¨ï¼Œåªä¸è¿‡å°†æ•°ç»„å…ƒç´ ä¿®æ”¹ä¸ºå•é“¾è¡¨ã€‚ä¸€æ—¦å‘ç”Ÿå“ˆå¸Œå†²çªæ˜ å°„åˆ°äº†åŒä¸€ä¸ªæ•°ç»„ä½ç½®ï¼Œå°±åœ¨å¯¹åº”ä½ç½®çš„å•é“¾è¡¨ä¸­å¾€åæ‹‰é“¾å³å¯ï¼›
2. å¼€æ”¾åœ°å€æ³• (Open Addressing)ã€‚è¯¥æ³•ä¿æŒåŸæ¥çš„ä¸€ç»´æ•°ç»„ç»“æ„ä¸å˜ï¼Œå°†äº§ç”Ÿå“ˆå¸Œå†²çªçš„å…ƒç´ ç§»åŠ¨åˆ°å…¶ä»–è¿˜æ²¡æœ‰è¢«å ç”¨çš„ä½ç½®ï¼ˆç§°ä¸ºç©ºæ¡¶ï¼‰å­˜å‚¨ã€‚è¿™ç§æ–¹æ³•åœ¨é¢‘ç¹äº§ç”Ÿå“ˆå¸Œå†²çªæ—¶æ€§èƒ½è¾ƒå·®ã€‚è€Œä¸ºäº†æ‰¾åˆ°å…¶ä»–ç©ºä½ï¼Œå¼€æ”¾åœ°å€æ³•éœ€è¦è¿›è¡Œã€Œç©ºæ¡¶æ¢æµ‹ã€ï¼Œå¸¸è§çš„æ¢æµ‹æ–¹æ³•æœ‰çº¿æ€§æ¢æµ‹ï¼ˆä»äº§ç”Ÿå†²çªçš„åœ°æ–¹å¼€å§‹æ²¿ç€æŸä¸ªæ–¹å‘æšä¸¾ï¼‰ã€åŒé‡å“ˆå¸Œæ¢æµ‹ï¼ˆåˆ©ç”¨ç¬¬äºŒä¸ªå“ˆå¸Œå‡½æ•°æ¢æµ‹å…¶ä½™ä½ç½®ï¼‰ã€‚

**å“ˆå¸Œè¡¨çš„æ•°æ®ç»“æ„**ã€‚åœ¨ C++ çš„ unordered_map åº“ä¸­ï¼Œunordered_map ä¸ unordered_multimap çš„åŸºç±» _Hashtable å®šä¹‰äº†å“ˆå¸Œè¡¨çš„å…·ä½“ç»“æ„ã€‚å…·ä½“åœ°ï¼Œå…¶å®šä¹‰çš„å“ˆå¸Œè¡¨æ˜¯ä¸€ç»´åŠ¨æ€æ•°ç»„ï¼Œæ•°ç»„å…ƒç´ æ˜¯å‰å‘é“¾è¡¨ï¼ˆå³å•é“¾è¡¨ï¼‰ã€‚æºç  `/path/to/CLion/bin/mingw/lib/gcc/x86_64-w64-mingw32/13.1.0/include/c++/bits/hashtable.h` æ˜¯è¿™æ ·è§£é‡Šçš„ï¼š

> In terms of Standard containers the hashtable is like the aggregation of:
>
> *  std:: forward_list <_Node \> containing the elements
> *  std:: vector < std:: forward_list <_Node \>:: iterator > representing the buckets

!!! tip
    è‡³æ­¤æ‰€æœ‰çš„çº¿æ€§æ•°æ®ç»“æ„å·²ç»åŸºæœ¬ä»‹ç»å®Œæ¯•ï¼Œæ¥ä¸‹æ¥å°±å¼€å§‹éçº¿æ€§æ•°æ®ç»“æ„çš„è®²è§£ğŸ˜Šã€‚

## å¹¿ä¹‰è¡¨

å¹¿ä¹‰è¡¨å¯ä»¥çœ‹ä½œå•é“¾è¡¨çš„æ‰©å±•ç‰ˆï¼Œå¯ä»¥åº”ç”¨åœ¨å­˜å‚¨ç©ºé—´çš„åˆ†é…ç­–ç•¥ä¸Šï¼Œå¯¹åº”çš„ç®—æ³•å«åšã€Œæˆç»„æ‹‰é“¾æ³•ã€ã€‚å…¶ç»“ç‚¹éœ€è¦å­˜å‚¨ä¸‰ç±»æ•°æ®ï¼Œç¤ºæ„å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š

![å¹¿ä¹‰è¡¨ç»“ç‚¹ç»“æ„ç¤ºæ„å›¾](https://cdn.dwj601.cn/images/202406292218530.png)

/// fc
å¹¿ä¹‰è¡¨ç»“ç‚¹ç»“æ„ç¤ºæ„å›¾
///

å…·ä½“åœ°ï¼š

1. `type`ï¼šå­˜å‚¨å½“å‰ç»“ç‚¹çš„ç±»å‹ã€‚ä»¥æšä¸¾ç±»å‹å­˜åœ¨ï¼Œèµ·æ ‡è¯†ä½œç”¨ã€‚å› æ­¤ `type` æ˜¯ä¸€ä¸ªæšä¸¾ä½“ (enum)ï¼›

- `data/sublist`ï¼šå­˜å‚¨å½“å‰ç»“ç‚¹çš„å†…å®¹ã€‚å¦‚æœæ˜¯ data ç±»å‹çš„ç»“ç‚¹ï¼Œå°±å­˜å‚¨æ•°æ®ï¼›å¦‚æœæ˜¯ sublist ç±»å‹çš„ç»“ç‚¹ï¼Œå°±å­˜å‚¨å­é“¾è¡¨çš„åœ°å€ã€‚å› æ­¤ `data/sublist` æ˜¯ä¸€ä¸ªè”åˆä½“ (union)ï¼›
- `next`ï¼šå­˜å‚¨ä¸‹ä¸€ä¸ªç»“ç‚¹çš„åœ°å€ã€‚å› æ­¤ `next` æ˜¯ä¸€ä¸ªæŒ‡é’ˆã€‚

å¹¿ä¹‰è¡¨ç»“ç‚¹çš„ C++ ä»£ç å¦‚ä¸‹ï¼š

```c++
enum GListNodeType {
    ATOM, LIST
};
template<class T>
struct GListNode {
    GListNodeType type;
    union {
        T data;
        GListNode* sublist;
    };
    GListNode<T>* next;
};
```

å¹¿ä¹‰è¡¨çš„ç»“æ„ç¤ºä¾‹å›¾å¦‚ä¸‹ï¼š

![å¹¿ä¹‰è¡¨çš„ç»“æ„ç¤ºæ„å›¾](https://cdn.dwj601.cn/images/202406292218531.png)

/// fc
å¹¿ä¹‰è¡¨çš„ç»“æ„ç¤ºæ„å›¾
///

### ä¾‹ä¸€

| æ ‡ç­¾ ğŸ· | éš¾åº¦ ğŸ”¥  |                     é“¾æ¥ ğŸ”—                     | ç­–ç•¥ â­ |
| :----: | :-----: | :--------------------------------------------: | :----- |
| å¹¿ä¹‰è¡¨ | æ´›è°· é»„ | [æ´›è°·](https://www.luogu.com.cn/problem/P1928) | å¹¿ä¹‰è¡¨ |

é¢˜æ„ï¼šç»™å®šä¸€ä¸ªå‹ç¼©åçš„å¯†ç ä¸²ï¼Œéœ€è¦è§£å‹ä¸ºåŸæ¥çš„å½¢å¼ï¼ˆä¿è¯ä¸è¶…è¿‡ $20000$ ä¸”æœ€å¤š $10$ å±‚å‹ç¼©ï¼‰ã€‚ä¾‹å¦‚ï¼š

1. `AC[3FUN]` $\to$ `ACFUNFUNFUN`ï¼›
2. `AB[2[2GH]]OP[2PQ]CD` $\to$ `ABGHGHGHGHOPPQPQCD`ã€‚

æ€è·¯ï¼š

- å‹ç¼©å¯†ç ä¸²çš„ç»“æ„å¾ˆåƒå¹¿ä¹‰è¡¨ï¼Œå³å­˜åœ¨ä¸²è¡Œçš„çºµå‘é€’å½’ç»“æ„ï¼Œæ¯”å¦‚ä¸Šè¿°ç¬¬äºŒä¸ªæ ·ä¾‹ä¸­ `[2[2GH]]` ä¸ `[2PQ]` å°±æ˜¯ä¸²è¡Œçš„é€’å½’ç»“æ„ï¼›
- å¯¹äºæ­¤ç±»æ•°æ®ç»“æ„ï¼Œä¸€å®šä¸èƒ½å¿˜è®°å¤„ç†åç»­ä¸²è¡Œçš„é€’å½’ç»“æ„ï¼Œä»¥åŠéœ€è¦æ³¨æ„ç´¢å¼•å˜é‡çš„å¼•ç”¨é—®é¢˜ã€‚ç”±äº Python æ²¡æœ‰å¯¹å•ä¸€æ•´æ•°çš„å¼•ç”¨è¯­æ³•ï¼Œå› æ­¤ä½¿ç”¨å…¨å±€å˜é‡ä»£æ›¿ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

=== "Python"

    ```python
    s = input().strip()
    i = 0
    
    def dfs() -> str:
        global i
        now = ""
    
        # é€’å½’ç»ˆç‚¹
        if i >= len(s):
            return now
    
        # å¤„ç†å‰ç¼€
        while i < len(s) and s[i].isalpha():
            now += s[i]
            i += 1
    
        # é€’å½’å¤„ç†
        if i < len(s) and s[i] == '[':
            i += 1
            x = 0
            while i < len(s) and s[i].isdigit():
                x = x * 10 + int(s[i])
                i += 1
            now += x * dfs()
        if i < len(s) and s[i] == ']':
            i += 1
            return now
    
        # å¤„ç†åç¼€
        now += dfs()
    
        return now
    
    print(dfs())
    ```

=== "C++"

    ```c++
    #include <iostream>
    
    using namespace std;
    
    string s;
    
    string dfs(int& i) {
        int n = s.size();
        string now = "";
    
        // é€’å½’ç»ˆç‚¹
        if (i >= n) {
            return now;
        }
        
        // å¤„ç†å‰ç¼€
        while (i < n and isalpha(s[i])) {
            now += s[i++];
        }
    
        // é€’å½’å¤„ç†
        if (i < n && s[i] == '[') {
            i++;
            int x = 0;
            while (i < n && isdigit(s[i])) {
                x = x * 10 + (s[i++] - '0');
            }
            string t = dfs(i);
            while (x--) {
                now += t;
            }
        }
        if (i < n && s[i] == ']') {
            i++;
            return now;
        }
    
        // å¤„ç†å°¾ä¸²
        now += dfs(i);
    
        return now;
    }
    
    int main() {
        cin >> s;
        int i = 0;
        cout << dfs(i) << "\n";
    
        return 0;    
    }
    ```

## æ ‘

æ ‘å…¶å®æ˜¯ä¸€ç§ç‰¹æ®Šçš„å›¾ï¼Œå³æ— ç¯å›¾ã€‚å¤šæ£µæ ‘å°±ç»„æˆäº†ä¸€ä¸ªæ£®æ—ã€‚æˆ‘ä»¬ç§°æ ‘ä¸­æ¯ä¸€ä¸ªç»“ç‚¹çš„å­ç»“ç‚¹æ•°é‡ä¸ºè¯¥ç»“ç‚¹çš„åº¦ï¼ŒåŒæ—¶å¯¹äºä¸€æ£µæ ‘ï¼Œæœ‰æ—¶ä¼šç§°å…¶ä¸º $x$ å‰æ ‘ï¼Œè¿™é‡Œçš„ $x$ å³æ ‘ä¸­ç»“ç‚¹åº¦æ•°çš„æœ€å¤§å€¼ã€‚

**æ ‘çš„å­˜å‚¨**ã€‚ä¸å¹¿ä¹‰è¡¨ç±»å‹ï¼Œæˆ‘ä»¬åŒæ ·ç”¨é“¾è¡¨æ¥å­˜å‚¨æ ‘ã€‚ä¸‹é¢ä»‹ç»ä¸¤ç§è¾ƒä¸ºå¸¸è§çš„æ ‘çš„å­˜å‚¨æ–¹å¼ï¼š

1. å¤šå‰é“¾è¡¨è¡¨ç¤ºæ³•ã€‚å³æ¯ä¸€ä¸ªç»“ç‚¹å­˜å‚¨æ‰€æœ‰çš„å­©å­ç»“ç‚¹çš„æŒ‡é’ˆï¼Œå¯ä»¥ç”¨é™æ€æ•°ç»„å­˜å‚¨ï¼Œä½†æ˜¯è¿™éœ€è¦å°†æ•°ç»„ç©ºé—´å¼€åˆ°ç»“ç‚¹çš„æœ€å¤§åº¦æ•°ï¼Œæœ‰äº›æµªè´¹ç©ºé—´ã€‚å› æ­¤å¯ä»¥ä½¿ç”¨åŠ¨æ€æ•°ç»„æ¥å­˜å‚¨æ‰€æœ‰å­©å­ç»“ç‚¹çš„æŒ‡é’ˆï¼›
2. å­©å­å…„å¼Ÿè¡¨ç¤ºæ³•ã€‚å³æ¯ä¸€ä¸ªç»“ç‚¹åªå­˜å‚¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œå…¶ä¸­å·¦æŒ‡é’ˆæŒ‡å‘å½“å‰ç»“ç‚¹çš„å­©å­ç»“ç‚¹ï¼Œå³æŒ‡é’ˆæŒ‡å‘å½“å‰ç»“ç‚¹çš„å…„å¼Ÿç»“ç‚¹ã€‚

**äºŒå‰æ ‘**ã€‚å³æ ‘ä¸­çš„æ¯ä¸€ä¸ªç»“ç‚¹æœ€å¤šåªæœ‰ä¸¤ä¸ªå­©å­ç»“ç‚¹ã€‚äºŒå‰æ ‘ä¸­æœ‰ä¸¤ç§æ¯”è¾ƒç‰¹æ®Šçš„æƒ…å†µï¼Œå³ï¼š

1. æ»¡äºŒå‰æ ‘ã€‚æ¯ä¸€å±‚éƒ½æ˜¯æ»¡ç»“ç‚¹ï¼›

2. å®Œå…¨äºŒå‰æ ‘ï¼šå¯¹äºä¸€ä¸ª $k$ å±‚çš„äºŒå‰æ ‘ï¼Œ$1\to k-1$ éƒ½æ˜¯æ»¡çš„ï¼Œç¬¬ $k$ å±‚çš„å¶å­ç»“ç‚¹ä»å·¦åˆ°å³æ’åˆ—ã€‚


ç”±äºäºŒå‰æ ‘å¯¹åº”çš„ç®—æ³•æ¯”è¾ƒå¤šï¼Œå°±æ”¾åœ¨åé¢çš„å›¾è®ºä¸­è¯¦ç»†ä»‹ç»ï¼Œæ­¤å¤„æˆ‘ä»¬åªä»‹ç»ä¸¤ç§äºŒå‰æ ‘çš„ã€Œæ„é€ æ–¹æ³•ã€ã€‚å…·ä½“åœ°ï¼š

- ç”¨ä¸€ä¸ªå«æœ‰ç©ºæŒ‡é’ˆæ ‡è®°çš„éå†åºåˆ—æ„é€ äºŒå‰æ ‘ã€‚æœ‰å¦‚ä¸‹ä¸‰ç§æƒ…å†µï¼š

    1. å…ˆåºåºåˆ—è¿›è¡Œæ„é€ ã€‚æŒ‰ç…§éå†çš„æ€è·¯æ¥ï¼Œå¯¹äºå…ˆåºåºåˆ—è€Œè¨€ï¼Œç¬¬ä¸€ä¸ªå…ƒç´ ä¸€å®šæ˜¯æ ¹å…ƒç´ ï¼Œå› æ­¤é¦–å…ˆæ ¹æ®â€œå½“å‰å±€é¢â€çš„ç¬¬ä¸€ä¸ªå…ƒç´ åˆ›å»ºæ ¹ç»“ç‚¹ï¼Œæ¥ç€é€’å½’åˆ›å»ºå·¦å­æ ‘å’Œå³å­æ ‘å³å¯ï¼Œé€’å½’ç»ˆç‚¹å°±æ˜¯ç©ºæŒ‡é’ˆæ ‡è®°ã€‚
    2. ä¸­åºåºåˆ—è¿›è¡Œæ„é€ ã€‚ ä¸å¯ä»¥ï¼Œå› ä¸ºä¸èƒ½ç¡®å®šæ ¹èŠ‚ç‚¹ä»¥åŠå·¦å­æ ‘å’Œå³å­æ ‘çš„éƒ¨åˆ†ã€‚
    3. ååºåºåˆ—è¿›è¡Œæ„é€ ã€‚ä¸ä¸Šè¿°å…ˆåºåºåˆ—è¿›è¡Œæ„å»ºçš„é€»è¾‘ç±»ä¼¼ï¼Œæˆ‘ä»¬ä»ååºåºåˆ—çš„æœ€åä¸€ä¸ªå…ƒç´ å¼€å§‹æ„å»ºï¼Œç¬¬ä¸€ä¸ªå…ƒç´ å°±æ˜¯æ ¹ç»“ç‚¹ï¼Œç„¶åå†åˆ†åˆ«é€’å½’æ„å»ºå³å­æ ‘å’Œå·¦å­æ ‘ï¼Œé€’å½’ç»ˆç‚¹åŒæ ·ä¹Ÿæ˜¯ç©ºæŒ‡é’ˆæ ‡è®°ã€‚

- ç”¨ä¸¤ä¸ªä¸å«ç©ºæŒ‡é’ˆæ ‡è®°çš„éå†åºåˆ—æ„é€ äºŒå‰æ ‘ã€‚æœ‰å¦‚ä¸‹ä¸¤ç§æƒ…å†µï¼š

    1. å…ˆåºåºåˆ— + ä¸­åºåºåˆ—ã€‚ç°åœ¨æˆ‘ä»¬æ²¡æœ‰ç©ºæŒ‡é’ˆæ ‡è®°äº†ï¼Œé‚£ä¹ˆå¦‚ä½•ç¡®å®šé€’å½’ç»ˆç‚¹å‘¢ï¼Ÿå¯ä»¥æ ¹æ®å…ˆåºåºåˆ—çš„é¦–ä¸ªå…ƒç´ åœ¨ä¸­åºåºåˆ—æŸ¥è¯¢ï¼ŒæŸ¥è¯¢ç»“æœçš„å·¦åŠéƒ¨åˆ†å°±æ˜¯å·¦å­æ ‘ï¼Œå³åŠéƒ¨åˆ†å°±æ˜¯å³å­æ ‘ï¼ŒåŸºäºæ­¤è¿›è¡Œæ„é€ å³å¯ã€‚
    2. ååºåºåˆ— + ä¸­åºåºåˆ—ã€‚ä¸ä¸Šè¿°ä¸€è‡´ï¼Œä¸å†èµ˜è¿°ã€‚

**çº¿ç´¢äºŒå‰æ ‘**ã€‚äºŒå‰æ ‘çš„æ‰©å±•ç‰ˆï¼Œå°†äºŒå‰æ ‘ä¸­æ‰€æœ‰ç»“ç‚¹çš„ç©ºæŒ‡é’ˆæŒ‡å‘å…¶å‰é©±æˆ–åç»§ç»“ç‚¹ã€‚

**å“ˆå¤«æ›¼æ ‘**ã€‚ä¸€ç§åˆ©ç”¨è´ªå¿ƒçš„ç®—æ³•æ€æƒ³è®¾è®¡å‡ºæ¥çš„ç¼–ç æ–¹å¼ï¼Œå¯ä»¥è¾¾åˆ°æœ€ä½³çš„ç¼–ç å‹ç¼©æ•ˆæœï¼Œä»è€Œæå‡æ•°æ®åœ¨ä¿¡é“ä¸­çš„ä¼ è¾“æ•ˆç‡ã€‚æˆ‘ä»¬å®šä¹‰ä¸€æ£µæ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦ $\text{WPL}$ ä¸ºæ‰€æœ‰å¶å­ç»“ç‚¹ã€Œè·¯å¾„é•¿åº¦ $\times$ æƒé‡ã€ä¹‹å’Œã€‚$\text{WPL}$ æœ€å°çš„æ ‘å°±å«åšå“ˆå¤«æ›¼æ ‘ã€‚

å…·ä½“åœ°ï¼Œå¯¹äºä¸€ä¸ªç»“ç‚¹åºåˆ— $id \in [1,n]$ï¼Œæ¯æ¬¡é€‰æ‹©å…¶ä¸­æƒå€¼æœ€å°çš„ä¸¤ä¸ªç»“ç‚¹è¿›è¡Œåˆå¹¶ï¼Œåˆå¹¶ $n-1$ æ¬¡ä¹‹åå¾—åˆ°çš„äºŒå‰æ ‘å°±æ˜¯å“ˆå¤«æ›¼æ ‘ã€‚åŸºäºè¿™æ£µå“ˆå¤«æ›¼æ ‘ï¼Œæˆ‘ä»¬å°±å¯ä»¥å±•å¼€ä¿¡æ¯çš„ç¼–ç ä¸è§£ç å·¥ä½œã€‚

**äºŒå‰æœç´¢æ ‘ & å¹³è¡¡äºŒå‰æœç´¢æ ‘**ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦åœ¨ $O(\log n)$ æ—¶é—´å¤æ‚åº¦å†…å¯¹æ•°æ®è¿›è¡Œå¢åˆ æŸ¥æ”¹çš„æ“ä½œï¼Œå°±å¯ä»¥å¼•å…¥ã€ŒäºŒå‰æœç´¢æ ‘ (Binary Search Tree)ã€è¿™ä¸€æ•°æ®ç»“æ„ã€‚ç„¶è€Œï¼Œåœ¨æŸäº›æç«¯çš„æƒ…å†µä¸‹ï¼Œä¾‹å¦‚å½“æ’å…¥çš„æ•°æ®æ˜¯å•è°ƒä¸å‡æˆ–ä¸å¢æ—¶ï¼Œè¿™æ£µæ ‘å°±ä¼šé€€åŒ–ä¸ºä¸€æ¡é“¾ä»è€Œå¯¼è‡´æ‰€æœ‰çš„å¢åˆ æŸ¥æ”¹æ“ä½œé€€åŒ–åˆ° $O(n)$ï¼Œè¿™æ˜¯æˆ‘ä»¬ä¸æ„¿æ„çœ‹åˆ°çš„ã€‚å› æ­¤æˆ‘ä»¬å¼•å…¥ã€Œå¹³è¡¡äºŒå‰æœç´¢æ ‘ (Balanced Binary Search Tree) ç®€ç§°å¹³è¡¡æ ‘ã€è¿™ä¸€æ•°æ®ç»“æ„ã€‚

å…³äºå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œæœ‰éå¸¸å¤šçš„å˜ç§ä¸å®ç°ï¼Œä¸åŒçš„åº”ç”¨åœºæ™¯ä¼šé€‰æ‹©ä¸åŒçš„å˜ç§ã€‚ä¾‹å¦‚ï¼š

- ã€ŒTreapã€æ›´çµæ´»ï¼Œé€šè¿‡éšæœºåŒ–ä¼˜å…ˆçº§å®ç°é¢„æœŸçš„å¹³è¡¡ï¼Œä½†åœ¨æœ€åæƒ…å†µä¸‹å¯èƒ½é€€åŒ–ï¼›
- ã€ŒAVL æ ‘ã€ä¸¥æ ¼ä¿æŒå¹³è¡¡ï¼Œä¿è¯äº† $O(\log n)$ çš„æ€§èƒ½ï¼Œä½†åœ¨é¢‘ç¹æ’å…¥å’Œåˆ é™¤çš„åœºæ™¯ä¸‹å¯èƒ½æœ‰è¾ƒå¤§çš„æ—‹è½¬å¼€é”€ï¼›
- ã€Œçº¢é»‘æ ‘ã€é€šè¿‡è¾ƒå®½æ¾çš„å¹³è¡¡æ¡ä»¶å®ç°äº†è¾ƒå¥½çš„æ’å…¥å’Œåˆ é™¤æ€§èƒ½ï¼Œé€šå¸¸è¢«å¹¿æ³›ç”¨äºéœ€è¦é«˜æ•ˆæ’å…¥åˆ é™¤æ“ä½œçš„ç³»ç»Ÿï¼ˆå¦‚ STL ä¸­çš„ `map` å’Œ `set`ï¼‰ã€‚

ä¸€èˆ¬æ¥è¯´ï¼Œçº¢é»‘æ ‘æ˜¯ä¸€ä¸ªè¾ƒä¸ºé€šç”¨çš„é€‰æ‹©ï¼Œè€Œåœ¨éœ€è¦ä¸¥æ ¼å¹³è¡¡æ€§æ—¶ï¼ŒAVL æ ‘å¯èƒ½æ˜¯æ›´å¥½çš„é€‰æ‹©ã€‚æœ‰å…³å¹³è¡¡æ ‘çš„çŸ¥è¯†ç‚¹è¾ƒä¸ºå¤æ‚ï¼Œå°†ä¼šåœ¨ **è¿›é˜¶æ•°æ®ç»“æ„** éƒ¨åˆ†è¯¦ç»†å±•å¼€ã€‚

### ä¾‹ä¸€

| æ ‡ç­¾ ğŸ· |  éš¾åº¦ ğŸ”¥   |                            é“¾æ¥ ğŸ”—                            | ç­–ç•¥ â­   |
| :----: | :-------: | :----------------------------------------------------------: | :------- |
|   æ ‘   | CF 1400 * | [è“æ¡¥](https://www.lanqiao.cn/problems/5890/learning/?contest_id=145) | æ ‘çš„ç›´å¾„ |

é¢˜æ„ï¼šç»™å®šä¸€æ£µè¾¹æƒä¸ºæ­£çš„æ— å‘æ ‘ï¼Œå…±æœ‰ $n\ (1\le n \le 10^5)$ ä¸ªç»“ç‚¹ã€‚ç»™å‡ºã€Œåœ¨è®¿é—®åˆ°æ ‘ä¸­æ¯ä¸€ä¸ªç»“ç‚¹ã€æƒ…å†µä¸‹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ã€‚

æ€è·¯ï¼š

- ä¸éš¾å‘ç°ä¸€ä¸ªæ€§è´¨ã€‚å¯¹äºè®¿é—®çš„èµ·ç‚¹ä¸ç»ˆç‚¹ï¼Œè·¯å¾„æ€»é•¿åº¦ä¸€å®šæ˜¯ã€Œèµ·ç‚¹åˆ°ç»ˆç‚¹çš„ç®€å•è·¯å¾„é•¿åº¦ã€+ã€Œæ‰€æœ‰åˆ†æ”¯è·¯å¾„é•¿åº¦çš„ä¸¤å€ã€ï¼Œç­‰ä»·äºã€Œæ‰€æœ‰è¾¹ä¹‹å’Œçš„ä¸¤å€ã€-ã€Œèµ·ç‚¹åˆ°ç»ˆç‚¹çš„ç®€å•è·¯å¾„é•¿åº¦ã€ï¼›
- æœ‰äº†ä¸Šè¿°çš„æ€§è´¨ï¼Œä¸ºäº†æœ€å°åŒ–æ€»è·¯å¾„é•¿åº¦ï¼Œæˆ‘ä»¬åªéœ€è¦æ‰¾åˆ°ç®€å•è·ç¦»æœ€é•¿çš„ä¸¤ä¸ªç»“ç‚¹ä½œä¸ºèµ·ç‚¹ä¸ç»ˆç‚¹å³å¯ï¼Œè¿™é‡Œçš„ç®€å•è·¯å¾„å…¶å®å°±æ˜¯ã€Œæ ‘çš„ç›´å¾„ã€ï¼›
- ä¸ºäº†æ±‚è§£æ ‘çš„ç›´å¾„ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦ç¡®å®šç›´å¾„çš„ä¸¤ä¸ªç«¯ç‚¹ã€‚å®¹æ˜“è¯æ˜ï¼Œæ¯éå†ä¸€æ¬¡æ ‘å³å¯ç¡®å®šç›´å¾„çš„ä¸€ä¸ªç«¯ç‚¹ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

=== "Python"

    ```python
    from collections import deque
    
    n = int(input())
    g = [[] for _ in range(n + 1)]
    
    ans = 0
    for _ in range(n - 1):
        u, v, w = tuple(map(int, input().split()))
        g[u].append((v, w))
        g[v].append((u, w))
        ans += w << 1
    
    def bfs(u: int) -> tuple[int, int]:
        dst = [0] * (n + 1)
        vis = [False] * (n + 1)
        q = deque()
        dst[u] = 0
        vis[u] = True
        q.append(u)
        while len(q):
            u = q.popleft()
            for v, w in g[u]:
                if vis[v]:
                    continue
                dst[v] = dst[u] + w
                vis[v] = True
                q.append(v)
        max_d = max(dst)
        max_i = dst.index(max_d)
        return max_d, max_i
    
    _, max_i = bfs(1)
    max_d, _ = bfs(max_i)
    
    print(ans - max_d)
    ```

## å † 

å †æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ ‘ï¼Œå¯ä»¥é€šè¿‡ä¸€ä¸ªä¸€ç»´æ•°ç»„æ¥å®ç°è¯¥æ•°æ®ç»“æ„ã€‚å…·ä½“åœ°ï¼Œæˆ‘ä»¬åˆ©ç”¨ä¸€ä¸ªä¸€ç»´æ•°ç»„æ¥æ¨¡æ‹Ÿä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œå¦‚æœè¿™æ£µå®Œå…¨äºŒå‰æ ‘æ»¡è¶³ï¼š

- ä»»æ„ä¸€ä¸ªéå¶å­ç»“ç‚¹ $\le$ å®ƒçš„å­ç»“ç‚¹ï¼Œåˆ™ç§°è¯¥å®Œå…¨äºŒå‰æ ‘ä¸ºã€Œå°é¡¶å †ã€ï¼›
- ä»»æ„ä¸€ä¸ªéå¶å­ç»“ç‚¹ $\ge$ å®ƒçš„å­ç»“ç‚¹ï¼Œåˆ™ç§°è¯¥å®Œå…¨äºŒå‰æ ‘ä¸ºã€Œå¤§é¡¶å †ã€ã€‚

åˆ©ç”¨å †ç»“æ„ï¼Œæˆ‘ä»¬å¯ä»¥ $O(1)$ å¾—åˆ°åºåˆ—æœ€å€¼ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬èƒ½å¤Ÿåœ¨å¯æ¥å—çš„è®¡ç®—å¼€é”€ä¸‹åŠ¨æ€ç»´æŠ¤åºåˆ—çš„å †ç»“æ„ï¼Œé‚£ä¹ˆå°±å¯ä»¥å¾ˆæ–¹ä¾¿çš„ç»´æŠ¤åºåˆ—çš„æœ€å€¼ã€‚

åŠ¨æ€ç»´æŠ¤å †ç»“æ„çš„é€»è¾‘å¹¶ä¸å¤æ‚ï¼Œä»¥å°é¡¶å †ä¸ºä¾‹ã€‚å¦‚æœè¦æ”¹å˜å †ä¸­ä»»æ„ä¸€ä¸ªå…ƒç´ ï¼Œæ— éå°±æ˜¯å°†æ–°å…ƒç´ é€’å½’åœ°ä¸å­ç»“ç‚¹äº¤æ¢ï¼ˆè¿™è¢«ç§°ä¸º `down()` æ“ä½œï¼‰ï¼Œæˆ–è€…å°†æ–°å…ƒç´ é€’å½’åœ°ä¸çˆ¶ç»“ç‚¹äº¤æ¢ï¼ˆè¿™è¢«ç§°ä¸º `up()` æ“ä½œï¼‰ã€‚

ä¸‹é¢å…·ä½“ä»‹ç»å †æ”¯æŒçš„æ“ä½œä¸ç®—æ³•é€»è¾‘ã€‚è®°å †ä¸­æœ€åä¸€å±‚çš„æœ€åä¸€ä¸ªå…ƒç´ åœ¨å †ä¸­çš„ä¸‹æ ‡ç´¢å¼•ä¸º `last`ï¼š

- æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚ä»æ ¹ç»“ç‚¹å¼€å§‹ `down()`ï¼Œæˆ–ä» `last` å¼€å§‹ `up()`ï¼›
- è¾“å‡ºæœ€å€¼ã€‚è¿”å›æ ¹ç»“ç‚¹ï¼›
- åˆ é™¤æœ€å€¼ï¼ˆå¦‚æœä¸å”¯ä¸€åˆ™åªåˆ é™¤ä¸€ä¸ªï¼‰ã€‚å°† `heap[last]` ä»æ ¹ç»“ç‚¹å¼€å§‹ `down()`ï¼›
- åˆ é™¤ä»»æ„ä¸€ä¸ªå…ƒç´ ã€‚å°† `heap[last]` ä»å¾…åˆ é™¤å…ƒç´ çš„ä½ç½®å¼€å§‹ï¼Œå¦‚æœæ¯”åŸæ¥çš„æ•°å¤§å°±å¾€ä¸‹ `down()`ï¼Œåä¹‹å°±å¾€ä¸Š `up()`ï¼Œå¦‚æœç›¸ç­‰å°±ä¸ç”¨æ“ä½œï¼›
- ä¿®æ”¹ä»»æ„ä¸€ä¸ªå…ƒç´ ã€‚ä¸åˆ é™¤å…ƒç´ é€»è¾‘ç±»ä¼¼ã€‚

## å›¾

å›¾æ˜¯ä¸€ç§ç”±é¡¶ç‚¹å’Œè¾¹ç»„æˆçš„æ•°æ®ç»“æ„ã€‚å¦‚æœè¾¹ä¸Šå¸¦æœ‰æƒé‡ï¼Œå°±ç§°è¯¥å›¾ä¸ºç½‘ã€‚å¯¹äºæ— å‘å›¾ï¼Œå¦‚æœæ¯ä¸€ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½æœ‰è·¯å¾„å¯è¾¾ï¼Œå°±ç§°è¯¥å›¾ä¸ºã€Œè¿é€šå›¾ã€ï¼Œæå¤§è¿é€šå­å›¾è¢«ç§°ä¸ºã€Œè¿é€šåˆ†é‡ã€ï¼›è€Œæœ‰å‘å›¾å°±å…¨éƒ¨åŠ ä¸€ä¸ª "å¼º" å­—ï¼Œå…¶ä»–å«ä¹‰ä¸å˜ï¼Œå³ã€Œå¼ºè¿é€šå›¾ã€å’Œã€Œå¼ºè¿é€šåˆ†é‡ã€ã€‚å¯¹äºæ— å‘å›¾ï¼Œç›´æ¥å¯è¾¾çš„ç»“ç‚¹æ•°è¢«ç§°ä¸ºã€Œåº¦ã€æ•°ï¼›å¯¹äºæœ‰å‘å›¾ï¼ŒæŒ‡å‡ºå»çš„ç›´æ¥å¯è¾¾ç»“ç‚¹æ•°è¢«ç§°ä¸ºã€Œå‡ºåº¦ã€æ•°ï¼ŒæŒ‡è¿›æ¥çš„çš„ç»“ç‚¹æ•°è¢«ç§°ä¸ºã€Œå…¥åº¦ã€æ•°ã€‚

**å›¾çš„å­˜å‚¨**ã€‚ä¸æ ‘ç±»ä¼¼ï¼Œå›¾ä¹Ÿå¯ä»¥ç”¨é“¾è¡¨æ¥å­˜å‚¨ï¼Œå›¾ä¸­ä¸€èˆ¬å°†å…¶ç§°ä¸ºé‚»æ¥è¡¨ï¼ˆä¸€èˆ¬éƒ½æ˜¯å­˜å‚¨å‡ºè¾¹ï¼Œå¦‚æœå­˜å‚¨å…¥è¾¹å°±å«åšé€†é‚»æ¥è¡¨ï¼‰ï¼Œä¹Ÿå¯ä»¥ç”¨é‚»æ¥çŸ©é˜µæ¥å­˜å‚¨ã€‚

**å›¾çš„éå†**ã€‚ç”±äºå›¾å¯èƒ½å«æœ‰ç¯ï¼Œå› æ­¤ç›¸è¾ƒäºæ ‘çš„éå†ï¼Œå›¾çš„éå†éœ€è¦æœ‰ä¸€ä¸ªè®¿é—®æ ‡è®°æ•°ç»„ã€‚ä¸€èˆ¬çš„éå†æ–¹æ³•å°±æ˜¯æ·±åº¦ä¼˜å…ˆå’Œå¹¿åº¦ä¼˜å…ˆï¼Œå¯¹äºæ±‚è§£ä¸¤ç‚¹ä¹‹é—´çš„ç®€å•è·¯å¾„é—®é¢˜ï¼Œæ·±åº¦ä¼˜å…ˆéå†å¯ä»¥å¾ˆå¥½çš„è§£å†³ï¼›å¯¹äºæŸ“è‰²æ³•æ±‚äºŒéƒ¨å›¾é—®é¢˜ï¼Œå¹¿åº¦æœ‰ç‚¹éå†å¯ä»¥å¾ˆå¥½çš„è§£å†³ã€‚

è€ƒè™‘åˆ°æ­¤å¤„æ˜¯å¯¹æ•°æ®ç»“æ„çš„åˆæ­¥ä»‹ç»ï¼Œä¸ºäº†ç®€æ˜æ‰¼è¦ï¼Œå›¾çš„ç›¸å…³ç®—æ³•å°±åœ¨ **å›¾è®º** éƒ¨åˆ†ä¸­å†è¯¦ç»†ä»‹ç»ã€‚

## å¹¶æŸ¥é›†

TODO

å¹¶æŸ¥é›†è™½ç„¶ä¸€èˆ¬ç”¨æ¥è§£å†³é›†åˆé—®é¢˜ï¼Œä½†æ•°æ®ç»“æ„å®ç°ä¸Šæœ¬è´¨æ˜¯ä¸€ä¸ªç”±å¤šæ£µæœ‰å‘æ ¹æ ‘ç»„æˆçš„æ£®æ—ã€‚åœ¨é‡‡ç”¨äº†è·¯å¾„å‹ç¼©å’ŒæŒ‰ç§©åˆå¹¶åï¼Œæ¯ä¸€æ¬¡æŸ¥è¯¢ä¸æ’å…¥çš„æ—¶é—´å¤æ‚åº¦éƒ½ä¼šå‡æ‘Šä¸ºä¸€ä¸ªå¸¸æ•°ã€‚

æ‹“å±•åŸŸå¹¶æŸ¥é›†ï¼š[ä¾‹é¢˜](https://www.luogu.com.cn/article/kx2if31n)

| æ ‡ç­¾ ğŸ· | éš¾åº¦ ğŸ”¥  |                     é“¾æ¥ ğŸ”—                     | ç­–ç•¥ â­                          |
| :----: | :-----: | :--------------------------------------------: | :------------------------------ |
| å¹¶æŸ¥é›† | æ´›è°· ç»¿ | [æ´›è°·](https://www.luogu.com.cn/problem/P1525) | æ‰©å±•åŸŸå¹¶æŸ¥é›†ã€äºŒåˆ†å›¾ + äºŒåˆ†æŸ¥æ‰¾ |

é¢˜æ„ï¼šç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼Œå¯èƒ½ä¸è¿é€šï¼Œæ²¡æœ‰é‡è¾¹å’Œè‡ªç¯ã€‚ç°åœ¨éœ€è¦ç»™å›¾ä¸­çš„æ¯ä¸€æ¡æ— å‘è¾¹å®šå‘ï¼Œè¦æ±‚æ‰€æœ‰çš„è¾¹å®šå®Œå‘ä»¥å 0 å…¥åº¦çš„ç‚¹å°½å¯èƒ½çš„å°‘ï¼Œç»™å‡ºæœ€å°‘çš„ 0 å…¥åº¦ç‚¹çš„æ•°é‡ã€‚

æ€è·¯ï¼šæˆ‘ä»¬çŸ¥é“å¯¹äºä¸€æ£µæ ‘è€Œè¨€ï¼Œn ä¸ªç»“ç‚¹ä¸€å…±æœ‰ n-1 æ¡è¾¹ï¼Œä¹Ÿå°±å¯ä»¥è´¡çŒ® n-1 ä¸ªå…¥åº¦ï¼Œå› æ­¤è‡³å°‘æœ‰ä¸€ä¸ªç‚¹çš„å…¥åº¦ä¸º 0ã€‚è€Œå¦‚æœä¸æ˜¯ä¸€æ£µæ ‘ï¼Œå°±ä¼šæœ‰è‡³å°‘ n æ¡è¾¹ï¼Œä¹Ÿå°±è‡³å°‘å¯ä»¥è´¡çŒ® n ä¸ªå…¥åº¦ï¼Œé‚£ä¹ˆ n ä¸ªç»“ç‚¹å°±è‡³å°‘å…¨éƒ½æœ‰å…¥åº¦äº†ã€‚æ˜¾ç„¶çš„ï¼Œä¸€ä¸ªå›¾è‡³å°‘å«æœ‰ n æ¡è¾¹æ—¶å°±ä¸€å®šæœ‰ç¯ã€‚æœ‰äº†ä¸Šè¿°æ€è·¯ä»¥åå°±å¯ä»¥å‘ç°ï¼Œè¿™é“é¢˜æœ¬è´¨ä¸Šå°±æ˜¯åœ¨åˆ¤æ–­è¿é€šåˆ†é‡æ˜¯å¦å«æœ‰ç¯ï¼Œå¦‚æœæœ‰ç¯ï¼Œé‚£ä¹ˆè¯¥è¿é€šåˆ†é‡å®šå‘è¾¹ä»¥åå°±ä¸ä¼šäº§ç”Ÿ 0 å…¥åº¦çš„é¡¶ç‚¹ï¼Œåä¹‹ï¼Œå¦‚æœæ²¡æœ‰ç¯ï¼Œé‚£ä¹ˆå®šå‘è¾¹ä»¥åæœ€å°‘äº§ç”Ÿ 1 ä¸ª 0 å…¥åº¦çš„ç‚¹ã€‚

- ç®—æ³•ä¸€ï¼šéå†å›¾ã€‚æˆ‘ä»¬é‡‡ç”¨ dfs éå†çš„æ–¹å¼å³å¯è§£å†³é—®é¢˜ã€‚ä¸€è¾¹éå†ä¸€è¾¹æ‰“æ ‡è®°ï¼Œé‡åˆ°å·²ç»æ‰“è¿‡æ ‡è®°çš„éçˆ¶ç»“ç‚¹å°±è¡¨æ˜å½“å‰è¿é€šåˆ†é‡æœ‰ç¯ã€‚æˆ‘ä»¬ä½¿ç”¨ C++ å®ç°ã€‚
- æ—¶é—´å¤æ‚åº¦ï¼š$O(n+m)$
- ç®—æ³•äºŒï¼šå¹¶æŸ¥é›†ã€‚ç”±äºæ²¡æœ‰é‡è¾¹ï¼Œå› æ­¤åœ¨åˆ¤æ–­æ¯ä¸€ä¸ªè¿é€šåˆ†é‡æ˜¯å¦å«æœ‰ç¯æ—¶ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡è¯¥è¿é€šåˆ†é‡ä¸­ç‚¹å’Œè¾¹çš„æ•°é‡å…³ç³»å¾—åˆ°ç»“æœã€‚æˆ‘ä»¬ä½¿ç”¨ Python å’Œ JavaScript å®ç°
- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

### ä¾‹ä¸€

=== "Python DSU"

    ```python
    p = [_ for _ in range(100010)]
    
    def Find(x: int) -> int:
        if x != p[x]: p[x] = Find(p[x])
        return p[x]
    
    def solve() -> None:
        n, m = map(int, input().split())
    
        edgeNum = [0] * (n + 1) # æ¯ä¸ªç‚¹çš„è¿è¾¹æ•°
    
        for _ in range(m):
            u, v = map(int, input().split())
            edgeNum[u] += 1
            edgeNum[v] += 1
            p[Find(u)] = Find(v)
    
        union = {}
    
        class node:
            def __init__(self):
                self.v = self.e = 0
    
        for i in range(1, n + 1):
            nowp = Find(i)
            if nowp not in union: union[nowp] = node()
            union[nowp].v += 1
            union[nowp].e += edgeNum[i]
    
        res = 0
    
        for comp in union:
            if union[comp].e >> 1 == union[comp].v - 1:
                res += 1
    
        print(res)
    
    if __name__ == "__main__":
        solve()
    ```

=== "C++ DFS"

    ```cpp
    #include <iostream>
    #include <cstring>
    #include <vector>
    #include <queue>
    #include <stack>
    #include <algorithm>
    #include <unordered_map>
    #include <set>
    using namespace std;
    
    const int N = 100010;
    
    int n, m;
    vector<int> G[N];
    bool vis[N];
    
    void dfs(int fa, int now, bool& hasLoop) {
        vis[now] = true;
        for (auto& ch: G[now]) {
            if (ch != fa) {
                if (vis[ch]) hasLoop = true;
                else dfs(now, ch, hasLoop);
            }
        }
    }
    
    void solve() {
        cin >> n >> m;
        while (m--) {
            int a, b;
            cin >> a >> b;
            G[a].push_back(b);
            G[b].push_back(a);
        }
    
        int res = 0;
    
        for (int i = 1; i <= n; i++) {
            if (!vis[i]) {
                bool hasLoop = false;
                dfs(-1, i, hasLoop);
                if (!hasLoop) res++;
            }
        }
    
        cout << res << "\n";
    }
    
    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr), cout.tie(nullptr);
        int T = 1;
    //    cin >> T;
        while (T--) solve();
        return 0;
    }
    ```

=== "JavaScript DSU"

    ```javascript
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    
    let n = null;
    let m = null;
    let p = [], edgeNum = [];
    
    rl.on('line', line => {
        const [a, b] = line.split(' ').map(i => Number(i));
        if (n === null) {
            n = a;
            m = b;
            for (let i = 1; i <= n; i++) {
                p[i] = i;
                edgeNum[i] = 0;
            }
        } else {
            edgeNum[a]++;
            edgeNum[b]++;
            p[Find(a)] = Find(b);
        }
    });
    
    rl.on('close', () => {
        const res = solve();
        console.log(res);
    });
    
    function Find(x) {
        if (x != p[x]) p[x] = Find(p[x]);
        return p[x];
    }
    
    function solve() {
        let res = 0;
    
        // è‡ªå®šä¹‰ç»“æ„ä½“
        class Node {
            constructor() {
                this.v = 0;
                this.e = 0;
            }
        }
    
        /*
            å¦ä¸€ç§ç»“æ„ä½“å®šä¹‰æ–¹æ³•
            function Node() {
                this.v = 0;
                this.e = 0;
            }
        */
    
        // å“ˆå¸Œ
        let union = new Map();
    
        for (let i = 1; i <= n; i++) {
            let nowp = Find(i); // å½“å‰ç»“ç‚¹çš„ç¥–å®—ç»“ç‚¹ nowp
            if (!union.has(nowp)) union.set(nowp, new Node());
    
            union.get(nowp).v += 1;
            union.get(nowp).e += edgeNum[i];
        }
    
        // åˆ¤æ–­
        for (let i of union.keys()) {
            if (union.get(i).e >> 1 === union.get(i).v - 1) {
                res++;
            }
        }
    
        return res;
    }
    ```

## æ ‘çŠ¶æ•°ç»„

TODO

åˆ©ç”¨æ›´å¤šçš„åŒºé—´ç»´æŠ¤ä¸€ä¸ªåºåˆ—çš„ä¿¡æ¯ï¼Œæ‰€æœ‰ç»´æŠ¤ä¿¡æ¯çš„åŒºé—´ç»„æˆçš„å½¢çŠ¶å½¢å¦‚ä¸€æ£µæ ‘ï¼Œæ•…ç§°ä¸ºæ ‘çŠ¶æ•°ç»„ã€‚æ”¯æŒçš„æ“ä½œæœ‰ï¼š

- åŒºé—´æŸ¥è¯¢ï¼šæŸ¥è¯¢åºåˆ— `[1, pos]` ç´¢å¼•çš„å…ƒç´ ä¹‹å’Œã€‚æ—¶é—´å¤æ‚åº¦ $O(\log n)$ï¼›
- å•ç‚¹ä¿®æ”¹ï¼šä¿®æ”¹åºåˆ— `pos` ç´¢å¼•çš„å…ƒç´ å€¼ã€‚æ—¶é—´å¤æ‚åº¦ $O(\log n)$ã€‚

æ›´å¤šå†…å®¹è§ï¼š[æ ‘çŠ¶æ•°ç»„ - OI Wiki](https://o-iwiki.org/ds/fenwick/)

## çº¿æ®µæ ‘

TODO

## äºŒå‰æœç´¢æ ‘

äºŒå‰æœç´¢æ ‘åˆå«äºŒå‰æ’åºæ ‘ã€äºŒå‰æŸ¥æ‰¾æ ‘ã€‚

å®šä¹‰ï¼šæ ¹ç»“ç‚¹æ¯”å·¦å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„å€¼éƒ½å¤§ï¼Œæ¯”å³å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„å€¼éƒ½å°ã€‚å…³é”®å­—å”¯ä¸€ã€‚

æ“ä½œï¼šå¢åŠ ã€ä¿®æ”¹ã€æŸ¥è¯¢ã€åˆ é™¤ã€‚

åˆ¤å®šï¼šæƒ³è¦åˆ¤å®šä¸€æ£µäºŒå‰æ ‘æ˜¯å¦ä¸ºäºŒå‰æœç´¢æ ‘ï¼Œåªéœ€è¦åˆ¤æ–­ä¸­åºéå†çš„ç»“æœæ˜¯ä¸æ˜¯é€’å¢çš„å³å¯ï¼Œå¯ä»¥é‡‡å–ä¸­åºéå†åºåˆ—æ¯”å¯¹çš„æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥åœ¨é€’å½’éå†äºŒå‰æ ‘çš„è¿‡ç¨‹ä¸­é€šè¿‡è®°å½•å‰é©±ç»“ç‚¹çš„å€¼ç›´æ¥è¿›è¡Œæ¯”è¾ƒåˆ¤æ–­ã€‚æ—¶é—´å¤æ‚åº¦ $O(n)$ã€‚

## å¹³è¡¡äºŒå‰æœç´¢æ ‘

C++ ä¸­å«åš `std::map`ï¼ŒPython ä¸­å«åš `from sortedcontainers import SortedList`ã€‚

> ä¾‹ç¨‹ï¼š[åˆ‡è›‹ç³• - AcWing](https://www.acwing.com/activity/content/code/content/8475415/)
>
> å®˜æ–¹ï¼š[sortedlist.py - grantjenks/python-sortedcontainers](https://github.com/grantjenks/python-sortedcontainers/blob/master/src/sortedcontainers/sortedlist.py)

æœ‰åºåˆ—è¡¨ç±»ã€‚å¯¼å…¥æ–¹æ³• `from sortedcontainers import SortedList`ã€‚å¯ä»¥ç±»æ¯” C++ ä¸­çš„ `map` ç±»ã€‚å…±æœ‰ä»¥ä¸‹å†…å®¹ï¼Œå…¨éƒ¨éƒ½æ˜¯ $O(\log n)$ çš„æ—¶é—´å¤æ‚åº¦ï¼š

1. `add(value)`: æ·»åŠ ä¸€ä¸ªå€¼åˆ°æœ‰åºåˆ—è¡¨
2. `discard(value)`: åˆ é™¤åˆ—è¡¨ä¸­çš„å€¼ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
3. `remove(value)`: åˆ é™¤åˆ—è¡¨ä¸­çš„å€¼ï¼ˆå¿…é¡»å­˜åœ¨ï¼‰
4. `pop(index=-1)`: åˆ é™¤å¹¶è¿”å›æŒ‡å®šç´¢å¼•å¤„çš„å€¼
5. `bisect_left(value)`: è¿”å›æ’å…¥å€¼çš„æœ€å·¦ç´¢å¼•
6. `bisect_right(value)`: è¿”å›æ’å…¥å€¼çš„æœ€å³ç´¢å¼•
7. `count(value)`: è®¡ç®—å€¼åœ¨åˆ—è¡¨ä¸­çš„å‡ºç°æ¬¡æ•°

**Treap**ã€‚äºŒå‰æœç´¢æ ‘å’Œå †çš„ç»“åˆä½“ã€‚å®ƒé€šè¿‡ç»´æŠ¤ä¸¤ç§æ€§è´¨æ¥ä¿æŒå¹³è¡¡ï¼š

>- **äºŒå‰æœç´¢æ ‘æ€§è´¨**ï¼šæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å°äºè¯¥èŠ‚ç‚¹çš„å€¼ï¼Œå³å­æ ‘çš„æ‰€æœ‰èŠ‚ç‚¹å€¼å¤§äºè¯¥èŠ‚ç‚¹çš„å€¼ã€‚
>- **å †æ€§è´¨**ï¼šæ¯ä¸ªèŠ‚ç‚¹çš„ä¼˜å…ˆçº§ï¼ˆé€šå¸¸éšæœºç”Ÿæˆï¼‰è¦å¤§äºæˆ–ç­‰äºå…¶å­èŠ‚ç‚¹çš„ä¼˜å…ˆçº§ã€‚
>
>**å¹³è¡¡æœºåˆ¶**ï¼š
>
>- Treap ä½¿ç”¨éšæœºåŒ–ä¼˜å…ˆçº§ä½¿å¾—æ ‘çš„å½¢çŠ¶æ¥è¿‘äºç†æƒ³çš„å¹³è¡¡æ ‘ï¼ˆæœŸæœ›æ ‘é«˜ä¸º $O(\log n)$ï¼‰ã€‚
>- é€šè¿‡æ—‹è½¬æ“ä½œï¼ˆå·¦æ—‹å’Œå³æ—‹ï¼‰åœ¨æ’å…¥å’Œåˆ é™¤æ—¶ä¿æŒå †çš„æ€§è´¨ã€‚
>
>**ä¼˜ç‚¹**ï¼š
>
>- å®ç°ç›¸å¯¹ç®€å•ã€‚
>- ç”±äºéšæœºåŒ–çš„ä¼˜å…ˆçº§ï¼Œåœ¨æœŸæœ›æƒ…å†µä¸‹ï¼Œæ ‘çš„é«˜åº¦æ˜¯ $O(\log n)$ã€‚
>- çµæ´»æ€§é«˜ï¼Œå¯ä»¥æ ¹æ®éœ€è¦è°ƒæ•´ä¼˜å…ˆçº§å‡½æ•°ã€‚
>
>**ç¼ºç‚¹**ï¼š
>
>- æœ€åæƒ…å†µä¸‹ï¼Œæ ‘çš„é«˜åº¦å¯èƒ½é€€åŒ–ä¸º $O(n)$ï¼ˆä¾‹å¦‚æ‰€æœ‰ä¼˜å…ˆçº§ç›¸åŒæˆ–é¡ºåºç”Ÿæˆçš„ä¼˜å…ˆçº§ï¼‰ï¼Œå°½ç®¡å‘ç”Ÿæ¦‚ç‡å¾ˆä½ã€‚

**AVL æ ‘**ã€‚æ˜¯æœ€æ—©è¢«å‘æ˜å‡ºæ¥çš„çš„è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œ1962 å¹´ç”± Adelson-Velsky å’Œ Landis å‘æ˜ã€‚


å®šä¹‰ï¼šå¹³è¡¡å› å­ä¸ºå·¦å­æ ‘çš„é«˜åº¦ - å³å­æ ‘çš„é«˜åº¦ï¼Œå¹³è¡¡äºŒå‰æ ‘çš„å¹³è¡¡å› å­ç»å¯¹å€¼ <= 1

æ„å»ºï¼šå½“æ’å…¥ç»“ç‚¹è¿›è¡Œæ„å»ºæ—¶å‡ºç°äº†æœ‰ç»“ç‚¹å¹³è¡¡å› å­çš„ç»å¯¹å€¼è¶…è¿‡äº† 1ï¼Œåˆ™è¿›è¡Œâ€œæ—‹è½¬â€è°ƒæ•´ï¼Œæ—‹è½¬å…±åˆ†ä¸º 4 ç§

![æ—‹è½¬ - LLã€LR](https://cdn.dwj601.cn/images/202406292218546.png)

/// caption

æ—‹è½¬ - LLã€LR

///

![æ—‹è½¬ - LR](https://cdn.dwj601.cn/images/202406292218547.png)

/// caption

æ—‹è½¬ - LR

///

![æ—‹è½¬ - RL](https://cdn.dwj601.cn/images/202406292218548.png)

/// caption

æ—‹è½¬ - RL

///

å°è¯•æ¨¡æ‹Ÿä¸€éä¸‹åˆ—åºåˆ—çš„æ„é€ è¿‡ç¨‹å°±å¯ä»¥ç†è§£äº†ï¼š

![ä¾‹é¢˜](https://cdn.dwj601.cn/images/202406292218549.png)

/// caption

ä¾‹é¢˜

///

>- **å¹³è¡¡å› å­**ï¼šæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å­æ ‘é«˜åº¦å·®ä¸èƒ½è¶…è¿‡ $1$ï¼Œä¸”éœ€è¦è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„é«˜åº¦ã€‚
>
>**å¹³è¡¡æœºåˆ¶**ï¼š
>
>- æ’å…¥æˆ–åˆ é™¤èŠ‚ç‚¹åï¼Œå¦‚æœæŸä¸ªèŠ‚ç‚¹çš„å¹³è¡¡å› å­ä¸å†ä¸º $-1$ã€$0$ æˆ– $1$ï¼Œå°±éœ€è¦é€šè¿‡æ—‹è½¬ï¼ˆå•æ—‹è½¬æˆ–åŒæ—‹è½¬ï¼‰æ¥æ¢å¤å¹³è¡¡ã€‚
>- æ—‹è½¬æ“ä½œåŒ…æ‹¬ï¼šå·¦æ—‹è½¬ã€å³æ—‹è½¬ã€å·¦å³åŒæ—‹è½¬å’Œå³å·¦åŒæ—‹è½¬ã€‚
>
>**ä¼˜ç‚¹**ï¼š
>
>- ä¸¥æ ¼çš„å¹³è¡¡æ¡ä»¶ä¿è¯äº†æ ‘çš„é«˜åº¦å§‹ç»ˆä¸º $O(\log n)$ï¼Œå› æ­¤æœç´¢ã€æ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ã€‚
>
>**ç¼ºç‚¹**ï¼š
>
>- ç”±äºå¹³è¡¡æ¡ä»¶ä¸¥æ ¼ï¼Œæ¯æ¬¡æ’å…¥å’Œåˆ é™¤åå¯èƒ½éœ€è¦è¾ƒå¤šçš„æ—‹è½¬æ“ä½œï¼Œä»è€Œå¯¼è‡´å®ç°è¾ƒå¤æ‚ï¼Œæ’å…¥å’Œåˆ é™¤æ“ä½œçš„å¸¸æ•°æ—¶é—´å¼€é”€è¾ƒå¤§ã€‚

**çº¢é»‘æ ‘**ã€‚ä¸€ç§è¾ƒä¸ºå®½æ¾çš„è‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œç”± Rudolf Bayer äº 1972 å¹´å‘æ˜ã€‚

> - **é¢œè‰²å±æ€§**ï¼šæ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰çº¢è‰²æˆ–é»‘è‰²ä¸¤ç§é¢œè‰²ï¼Œé€šè¿‡è¿™äº›é¢œè‰²çº¦æŸæ ‘çš„å¹³è¡¡æ€§ã€‚
>
> **å¹³è¡¡æœºåˆ¶**ï¼š
>
> - é€šè¿‡éµå¾ªçº¢é»‘æ ‘çš„äº”ä¸ªæ€§è´¨æ¥ä¿æŒå¹³è¡¡ï¼š
>     1. æ¯ä¸ªèŠ‚ç‚¹è¦ä¹ˆæ˜¯çº¢è‰²ï¼Œè¦ä¹ˆæ˜¯é»‘è‰²ã€‚
>     2. æ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²ã€‚
>     3. å¶å­èŠ‚ç‚¹ï¼ˆNIL èŠ‚ç‚¹ï¼‰æ˜¯é»‘è‰²ã€‚
>     4. å¦‚æœä¸€ä¸ªèŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œé‚£ä¹ˆå®ƒçš„å­èŠ‚ç‚¹å¿…é¡»æ˜¯é»‘è‰²ï¼ˆçº¢èŠ‚ç‚¹ä¸èƒ½è¿ç»­å‡ºç°ï¼‰ã€‚
>     5. ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å…¶æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„æ‰€æœ‰è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°é‡çš„é»‘è‰²èŠ‚ç‚¹ã€‚
> - æ’å…¥å’Œåˆ é™¤æ“ä½œå¯èƒ½ç ´åçº¢é»‘æ ‘çš„æ€§è´¨ï¼Œéœ€è¦é€šè¿‡é‡æ–°ç€è‰²å’Œæ—‹è½¬æ¥æ¢å¤å¹³è¡¡ã€‚
>
> **ä¼˜ç‚¹**ï¼š
>
> - çº¢é»‘æ ‘çš„é«˜åº¦æœ€å¤šæ˜¯ $\Theta (2  \log n)$ï¼Œå› æ­¤æœç´¢ã€æ’å…¥å’Œåˆ é™¤æ“ä½œçš„æ—¶é—´å¤æ‚åº¦ä»ä¸º $O(\log n)$ã€‚
> - ç”±äºå¹³è¡¡æ¡ä»¶è¾ƒä¸ºå®½æ¾ï¼Œæ’å…¥å’Œåˆ é™¤æ“ä½œéœ€è¦çš„æ—‹è½¬æ“ä½œé€šå¸¸æ¯” AVL æ ‘å°‘ï¼Œæ•ˆç‡æ›´é«˜ã€‚
>
> **ç¼ºç‚¹**ï¼š
>
> - å®ç°è¾ƒå¤æ‚ï¼Œç‰¹åˆ«æ˜¯æ’å…¥å’Œåˆ é™¤çš„å¹³è¡¡ä¿®å¤è¿‡ç¨‹ã€‚
> - è™½ç„¶çº¢é»‘æ ‘çš„æœç´¢æ•ˆç‡ä¸ AVL æ ‘ç›¸ä¼¼ï¼Œä½†ç”±äºå¹³è¡¡æ¡ä»¶è¾ƒå®½æ¾ï¼Œå®é™…åº”ç”¨ä¸­çš„æ ‘é«˜åº¦é€šå¸¸ç•¥é«˜äº AVL æ ‘ï¼Œå› æ­¤æœç´¢æ“ä½œçš„æ•ˆç‡ç¨ä½ã€‚

## å…³æŠ¼ç½ªçŠ¯ğŸ˜­

OJï¼š[æ´›è°·](https://www.luogu.com.cn/problem/P1525)

é¢˜æ„ï¼šç»™å®šä¸€ä¸ªå«æœ‰ $n\ (n\le2\cdot 10^4)$ ä¸ªé¡¶ç‚¹ $m\ (m\le10^5)$ æ¡è¾¹çš„æ— å‘å›¾ï¼Œæ²¡æœ‰é‡è¾¹å’Œè‡ªç¯ï¼Œè¾¹æƒ $w\ (1\le w_i\le 10^9)$ ä¸ºæ­£ã€‚ç°åœ¨éœ€è¦å°†å›¾ä¸­æ‰€æœ‰çš„é¡¶ç‚¹åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä½¿å¾—ä¸¤éƒ¨åˆ†ä¸­æœ€å¤§çš„è¾¹æƒå°½å¯èƒ½å°ï¼Œè¾“å‡ºè¯¥æœ€å°è¾¹æƒã€‚

æ€è·¯ä¸€ï¼šæ‹“å±•åŸŸå¹¶æŸ¥é›†

- TODO

æ€è·¯äºŒï¼šäºŒåˆ†å›¾ + äºŒåˆ†æŸ¥æ‰¾

- å‡è®¾ç­”æ¡ˆæ˜¯ $m$ æ¡è¾¹ä¸­æŸä¸€æ¡çš„æƒé‡ $w_i$ï¼Œé‚£ä¹ˆæ‰€æœ‰æƒé‡å°äº $w_i$ çš„è¾¹å¯¹åº”çš„é¡¶ç‚¹å¦‚ä½•åˆ†é…æ— å…³ç´§è¦ï¼Œæˆ‘ä»¬åªå…³æ³¨è¾¹æƒå¤§äº $w_i$ çš„è¾¹å¯¹åº”çš„é¡¶ç‚¹èƒ½ä¸èƒ½è¢«åˆ†åˆ°ä¸¤éƒ¨åˆ†ã€‚ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åªå…³å¿ƒè¾¹æƒå¤§äº $w_i$ çš„è¾¹å¯¹åº”çš„é¡¶ç‚¹ç»„æˆçš„å›¾æ˜¯å¦å¯äºŒåˆ†ã€‚é‡‡ç”¨æŸ“è‰²æ³•å³å¯å¿«é€Ÿåˆ¤å®šä¸€ä¸ªå›¾æ˜¯å¦å¯äºŒåˆ†ã€‚æ³¨æ„è¿™é‡Œçš„å¯äºŒåˆ†çš„å›¾å…¶å®ä¸ç¬¦åˆã€ŒäºŒåˆ†å›¾ã€çš„ä¸¥æ ¼å®šä¹‰ï¼Œå› ä¸ºä¸¤ä¸ªéƒ¨åˆ†çš„é¡¶ç‚¹ä¹‹é—´å¯èƒ½æœ‰è¿è¾¹ï¼›
- ç”±äº $w_i$ è¶Šå°éœ€è¦åˆ¤æ–­çš„é¡¶ç‚¹æ•°å°±è¶Šå¤šï¼Œå…·å¤‡äºŒåˆ†æ€§ã€‚å› æ­¤æˆ‘ä»¬ç›´æ¥åœ¨ $m$ æ¡è¾¹ä¸­äºŒåˆ†æŸ¥æ‰¾æœ€å°çš„ç¬¦åˆæ¡ä»¶çš„è¾¹å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(m\log n)$

*[äºŒåˆ†å›¾]: åˆç§°äºŒéƒ¨å›¾ (Bipartite Graph)ã€‚å®šä¹‰ä¸ºï¼šèŠ‚ç‚¹ç”±ä¸¤ä¸ªé›†åˆç»„æˆï¼Œä¸”ä¸¤ä¸ªé›†åˆå†…éƒ¨æ²¡æœ‰è¾¹çš„å›¾ã€‚

=== "Python äºŒåˆ†"

    ```cpp
    from collections import deque
    
    n, m = map(int, input().strip().split())
    edges = [(-1, -1, 0)]  # ä¸‹æ ‡ä» 1 å¼€å§‹
    for _ in range(m):
        u, v, w = map(int, input().strip().split())
        edges.append((u, v, w))
    
    edges.sort(key=lambda x: x[2])
    
    # æŸ“è‰²æ³• check äºŒåˆ†å›¾
    def chk(idx: int) -> bool:
        g = [[] for _ in range(n + 1)]
        for u, v, w in edges[idx + 1:]:
            g[u].append((v, w))
            g[v].append((u, w))
    
        color = [0] * (n + 1)
    
        def bfs(now: int) -> bool:
            color[now] = 1
            q = deque()
            q.append(now)
            while len(q):
                fa = q.popleft()
                for ch, _ in g[fa]:
                    if color[ch] == 0:
                        color[ch] = -color[fa]
                        q.append(ch)
                    elif color[ch] == color[fa]:
                        return False
            return True
    
        for i in range(1, n + 1):
            if color[i] == 0:
                ok = bfs(i)
                if not ok:
                    return False
        return True
    
    l, r = 0, m
    while l < r:
        mid = (l + r) >> 1
        if chk(mid):
            r = mid
        else:
            l = mid + 1
    
    print(edges[r][2])
    ```

=== "Python å¹¶æŸ¥é›†"

    ```python
    class DSU:
        def __init__(self, n: int) -> None:
            self.n = n
            self.sz = n                       # é›†åˆä¸ªæ•°
            self.p = [i for i in range(n)]    # p[i]è¡¨ç¤ºç¬¬iä¸ªç»“ç‚¹çš„ç¥–å®—ç¼–å·
            self.cnt = [1 for i in range(n)]  # cnt[i]è¡¨ç¤ºç¬¬iä¸ªç»“ç‚¹æ‰€åœ¨é›†åˆä¸­çš„ç»“ç‚¹æ€»æ•°
    
        def find(self, x: int) -> int:
            if self.p[x] != x:
                self.p[x] = self.find(self.p[x])
            return self.p[x]
    
        def merge(self, a: int, b: int) -> None:
            pa, pb = self.find(a), self.find(b)
            if pa != pb:
                self.p[pa] = pb
                self.cnt[pb] += self.cnt[pa]
                self.sz -= 1
    
        def same(self, a: int, b: int) -> bool:
            return self.find(a) == self.find(b)
    
        def size(self) -> int:
            return self.sz
    
        def size(self, a: int) -> int:
            return self.cnt[a]
    
    n, m = map(int, input().strip().split())
    edges = []
    for _ in range(m):
        u, v, w = map(int, input().strip().split())
        edges.append((u, v, w))
    
    edges.sort(key=lambda edge: -edge[2])
    dsu = DSU(n * 2 + 1)
    for u, v, w in edges:
        fu = dsu.find(u)
        fv = dsu.find(v)
        if fu == fv:
            print(w)
            exit()
        dsu.merge(u, v + n)
        dsu.merge(u + n, v)
    print(0)
    ```

åŒç±»é¢˜æ¨èï¼š

- [æ´›è°·ç»¿ | The Door Problem | æ´›è°· - (www.luogu.com.cn)](https://www.luogu.com.cn/problem/CF776D)
- [æ´›è°·ç»¿ | é£Ÿç‰©é“¾ | æ´›è°· - (www.luogu.com.cn)](https://www.luogu.com.cn/problem/P2024)

## ã€æ¨¡æ¿ã€‘åŒé“¾è¡¨

<https://www.acwing.com/problem/content/829/>

> æ€è·¯ï¼šç”¨ä¸¤ä¸ªç©ºç»“ç‚¹ä½œä¸ºèµ·å§‹çŠ¶æ€çš„è¾¹ç•Œï¼Œé¿å…æ‰€æœ‰è¾¹ç•Œè®¨è®ºã€‚
>
> æ—¶é—´å¤æ‚åº¦ï¼šæ’å…¥ã€åˆ é™¤ç»“ç‚¹å‡ä¸º $O(1)$ï¼Œéå†ä¸º $O(n)$

```cpp
#include <bits/stdc++.h>

using ll = long long;
using namespace std;

template<class T>
class myList {
private:
    int idx;
    std::vector<T> val;
    std::vector<int> left, right;

public:
    myList(const int n) {
        idx = 2;
        val.resize(n + 10);
        left.resize(n + 10);
        right.resize(n + 10);
        left[1] = 0, right[0] = 1;
    }

    void push_back(T x) {
        insert_left(1, x);
    }

    void push_front(T x) {
        insert_right(0, x);
    }

    void insert_left(int k, T x) {
        insert_right(left[k], x);
    }

    void insert_right(int k, T x) {
        val[idx] = x;
        right[idx] = right[k];
        left[right[k]] = idx;
        left[idx] = k;
        right[k] = idx++;
    }

    void erase(int k) {
        right[left[k]] = right[k];
        left[right[k]] = left[k];
    }

    void output() {
        for (int i = right[0]; i != 1; i = right[i]) {
            cout << val[i] << " \n"[i == 1];
        }
    }
};

void solve() {
    int n;
    cin >> n;

    myList<int> ls(n);

    while (n--) {
        string op;
        cin >> op;

        int k, x;

        if (op == "L") {
            cin >> x;
            ls.push_front(x);
        } else if (op == "R") {
            cin >> x;
            ls.push_back(x);
        } else if (op == "D") {
            cin >> k;
            ls.erase(k + 1);
        } else if (op == "IL") {
            cin >> k >> x;
            ls.insert_left(k + 1, x);
        } else {
            cin >> k >> x;
            ls.insert_right(k + 1, x);
        }
    }

    ls.output();
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int T = 1;
//    std::cin >> T;
    while (T--) solve();
    return 0;
}
```

```python
import heapq
from collections import defaultdict
from typing import List, Tuple
import math
from itertools import combinations

II = lambda: int(input())
FI = lambda: float(input())
MII = lambda: tuple(map(int, input().split()))
LII = lambda: list(map(int, input().split()))


class myList:
    def __init__(self, n: int) -> None:
        self.val = [0] * (n + 10)
        self.left = [0] * (n + 10)
        self.right = [0] * (n + 10)
        self.idx = 2
        self.right[0] = 1
        self.left[1] = 0

    def push_front(self, x: int):
        self.insert_right(0, x)

    def push_back(self, x: int):
        self.insert_left(1, x)

    def insert_left(self, k: int, x: int):
        self.insert_right(self.left[k], x)

    def insert_right(self, k: int, x: int):
        self.val[self.idx] = x
        self.right[self.idx] = self.right[k]
        self.left[self.right[k]] = self.idx
        self.left[self.idx] = k
        self.right[k] = self.idx
        self.idx += 1

    def erase(self, k: int):
        self.left[self.right[k]] = self.left[k]
        self.right[self.left[k]] = self.right[k]

    def output(self) -> None:
        i = self.right[0]
        while i != 1:
            print(self.val[i], end=' ')
            i = self.right[i]


def solve() -> None:
    n = II()

    ls = myList(n)

    for _ in range(n):
        op = input().split()

        if op[0] == 'L':
            ls.push_front(int(op[-1]))
        elif op[0] == 'R':
            ls.push_back(int(op[-1]))
        elif op[0] == 'D':
            ls.erase(int(op[-1]) + 1)
        elif op[0] == 'IL':
            ls.insert_left(int(op[1]) + 1, int(op[-1]))
        else:
            ls.insert_right(int(op[1]) + 1, int(op[-1]))

    ls.output()


if __name__ == '__main__':
    T = 1
    # T = II()
    while T: solve(); T -= 1
```

## ã€æ¨¡æ¿ã€‘å•è°ƒæ ˆ

<https://www.acwing.com/problem/content/832/>

> é¢˜æ„ï¼šå¯¹äºä¸€ä¸ªåºåˆ—ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå¯»æ‰¾æ¯ä¸€ä¸ªå…ƒç´ å·¦ä¾§æœ€è¿‘çš„æ¯”å…¶å°çš„å…ƒç´ ã€‚
>
> æ€è·¯ä¸€ï¼šæš´åŠ›æšä¸¾
>
> - æ˜¾ç„¶å¯¹äºæ¯ä¸€ä¸ªå…ƒç´  `nums[i]`ï¼Œæˆ‘ä»¬å¯ä»¥æšä¸¾å€’åº `[0, i-1]` ç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ª `nums[j] < nums[i]`
> - æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$
>
> æ€è·¯äºŒï¼šå•è°ƒæ ˆ
>
> - å¯ä»¥å‘ç°æ—¶é—´å¼€é”€ä¸»è¦åœ¨å€’åºæšä¸¾ä¸Šï¼Œæˆ‘ä»¬èƒ½å°‘æšä¸¾ä¸€äº›å…ƒç´ å—ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥çš„ã€‚æˆ‘ä»¬å®šä¹‰ã€Œå¯»æ‰¾ `[i-1, 0]` ä¸­æ¯”å½“å‰å…ƒç´ å°çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€çš„è¡Œä¸ºå«åšã€Œå¯»æ‰¾åˆæ³•å¯¹è±¡ã€ã€‚æ˜¾ç„¶æˆ‘ä»¬åœ¨æšä¸¾æ¯ä¸€ä¸ªå…ƒç´ æ—¶éƒ½éœ€è¦ **æŸ¥è¯¢** å’Œ **ç»´æŠ¤** è¿™æ ·çš„åˆæ³•å¯¹è±¡çº¿æ€§åºåˆ—ï¼Œå¯ä»¥ç†è§£ä¸ºè®°å¿†åŒ–ä»è€ŒåŠ é€ŸæŸ¥è¯¢ã€‚é‚£ä¹ˆå¦‚ä½•é«˜æ•ˆæŸ¥è¯¢å’Œç»´æŠ¤è¿™æ ·çš„çº¿æ€§åºåˆ—å‘¢ï¼Ÿä¸å¦¨è€ƒè™‘æ¯ä¸€ä¸ªåˆæ³•å¯¹è±¡å¯¹æ›¾ç»çš„åˆæ³•å¯¹è±¡çš„å½±å“ï¼š
>
>     - è‹¥å½“å‰å…ƒç´  `nums[i]` å¯ä»¥æˆä¸ºåç»­ `[i+1, n-1]` å…ƒç´ çš„åˆæ³•å¯¹è±¡ã€‚åˆ™ä» `i-1` å¼€å§‹ä¸€ç›´å¾€å·¦ï¼Œåªè¦æ¯”å½“å‰å¤§çš„å…ƒç´ ï¼Œéƒ½ä¸å¯èƒ½æˆä¸º `[i+1, n-1]` çš„åˆæ³•å¯¹è±¡ï¼Œè‚¯å®šéƒ½è¢« `nums[i]` â€œæ‹¦ä½äº†â€ã€‚é‚£ä¹ˆåœ¨ã€Œåˆæ³•å¯¹è±¡åºåˆ—ã€ä¸­æ’å…¥å½“å‰åˆæ³•å¯¹è±¡ä¹‹å‰ï¼Œéœ€è¦ä¸æ–­å°¾å¼¹å‡ºæ¯”å½“å‰å¤§çš„å…ƒç´ 
>     - è‹¥å½“å‰å…ƒç´  `nums[i]` ä¸èƒ½æˆä¸ºåç»­ `[i+1, n-1]` å…ƒç´ çš„åˆæ³•å¯¹è±¡ã€‚è¡¨æ˜å½“å‰å…ƒç´ è¿‡å¤§ï¼Œæ­¤æ—¶å°±ä¸ç”¨å°†å½“å‰å…ƒç´ æ’å…¥ã€Œåˆæ³•å¯¹è±¡åºåˆ—ã€
>
> - ç»è¿‡ä¸Šè¿°ä¸¤ä¸ªè§’åº¦çš„è®¨è®ºï¼Œå¾ˆå®¹æ˜“å‘ç°è¿™æ ·ç»´æŠ¤å‡ºæ¥çš„çš„åˆæ³•åºåˆ—æ˜¯ä¸¥æ ¼å•è°ƒé€’å¢çš„ã€‚äºæ˜¯ï¼Œåœ¨æŸ¥è¯¢æ“ä½œæ—¶ä»…éœ€è¦è¿›è¡Œå°¾æ¯”è¾ƒä¸å°¾å¼¹å‡ºå³å¯ï¼Œåœ¨ç»´æŠ¤æ“ä½œæ—¶ï¼Œä»…éœ€è¦å°¾æ’å…¥å³å¯ã€‚æ»¡è¶³è¿™æ ·çš„çº¿æ€§æ•°æ®ç»“æ„æœ‰å¾ˆå¤šï¼Œå¦‚æ ˆã€é˜Ÿåˆ—ã€æ•°ç»„ã€é“¾è¡¨ï¼Œæˆ‘ä»¬å°±ä½¿ç”¨æ ˆæ¥æ¼”ç¤ºï¼Œä¸æ ‡é¢˜é¥ç›¸å‘¼åº”
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```cpp
#include <bits/stdc++.h>

using ll = long long;
using namespace std;

void solve() {
    int n;
    cin >> n;

    vector<int> a(n);
    for (int i = 0; i < n; i++) {
        cin >> a[i];
    }

    stack<int> s;
    for (int i = 0; i < n; i++) {
        // æŸ¥è¯¢
        while (s.size() && s.top() >= a[i]) {
            s.pop();
        }
        cout << (s.size() ? s.top() : -1) << " ";
        
        // ç»´æŠ¤
        s.push(a[i]);
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int T = 1;
//    std::cin >> T;
    while (T--) solve();
    return 0;
}
```

ç›¸ä¼¼é¢˜ï¼š

[ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II](https://leetcode.cn/problems/next-greater-element-ii/)

## ã€æ¨¡æ¿ã€‘å•è°ƒé˜Ÿåˆ—

> æ ‡ç­¾ï¼šåŒç«¯é˜Ÿåˆ—ã€æ»‘åŠ¨çª—å£ã€å•è°ƒé˜Ÿåˆ—
>
> é¢˜æ„ï¼šç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªå…ƒç´ çš„åºåˆ—ï¼Œæ±‚è§£å…¶ä¸­æ¯ä¸ªé•¿åº¦ä¸º k çš„å­æ•°ç»„ä¸­çš„æœ€å€¼ã€‚
>
> æ€è·¯ï¼šæ˜¾ç„¶æˆ‘ä»¬å¯ä»¥ $O(nk)$ æš´åŠ›æ±‚è§£ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆæ–¹æ³•å¯ä»¥å°†ã€Œæ±‚è§£å­æ•°ç»„ä¸­æœ€å€¼ã€çš„æ—¶é—´å¼€é”€ä» $O(k)$ é™ä½ä¸º $O(1)$ å‘¢ï¼Ÿæœ‰çš„ï¼æˆ‘ä»¬é‡æ–°å®šä¹‰ä¸€ä¸ªé˜Ÿåˆ—å°±å¥½äº†ã€‚ä¸ºäº†åšåˆ°çº¿æ€§æ—¶é—´å¤æ‚åº¦çš„ä¼˜åŒ–ï¼Œæˆ‘ä»¬å¯¹é˜Ÿåˆ—åšä»¥ä¸‹è‡ªå®šä¹‰ï¼Œä»¥ã€Œæ±‚è§£å­æ•°ç»„æœ€å°å€¼ã€ä¸ºä¾‹ï¼š
>
> 1. æ’å…¥å…ƒç´ åˆ°é˜Ÿå°¾ï¼šæ­¤æ—¶å’Œå•è°ƒæ ˆçš„é€»è¾‘ç±»ä¼¼ã€‚å¦‚æœå½“å‰å…ƒç´ å¯ä»¥ä½œä¸ºå½“å‰å­æ•°ç»„æˆ–åç»­å­æ•°ç»„çš„æœ€å°å€¼ï¼Œåˆ™éœ€è¦ä»å½“å‰é˜Ÿå°¾å¼€å§‹ä¾æ¬¡å¼¹å‡ºæ¯”å½“å‰å…ƒç´ ä¸¥æ ¼å¤§çš„å…ƒç´ ï¼Œæœ€åå†å°†å½“å‰å…ƒç´ å…¥é˜Ÿã€‚**æ³¨æ„**ï¼šå½“é‡åˆ°å’Œå½“å‰å…ƒç´ å€¼ç›¸ç­‰çš„å…ƒç´ æ—¶ä¸èƒ½å‡ºé˜Ÿï¼Œå› ä¸ºæ¯ä¸€ä¸ªå…ƒç´ éƒ½ä¼šç»å†å…¥é˜Ÿå’Œå‡ºé˜Ÿçš„æ“ä½œï¼Œä¸€æ—¦æ­¤æ—¶å‡ºé˜Ÿäº†ï¼Œåç»­è¿›è¡Œå‡ºé˜Ÿåˆ¤å®šæ—¶ä¼šæå‰å¼¹å‡ºæœ¬ä¸åº”è¯¥å‡ºé˜Ÿçš„ä¸å…¶ç­‰å€¼çš„å…ƒç´ ã€‚
> 2. å¼¹å‡ºé˜Ÿå¤´å…ƒç´ ï¼šå¦‚æœé˜Ÿå¤´å…ƒç´ å’Œå­æ•°ç»„å·¦ç«¯ç‚¹ `nums[i-k]` çš„å…ƒç´ å€¼ç›¸ç­‰ï¼Œåˆ™å¼¹å‡ºã€‚
> 3. è·å¾—é˜Ÿå¤´å…ƒç´ ï¼š$O(1)$ çš„è·å–é˜Ÿå¤´å…ƒç´ ï¼Œå³é˜Ÿåˆ—ä¸­çš„æœ€å°å€¼ã€‚
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```cpp
#include <bits/stdc++.h>

using ll = long long;
using namespace std;

template<class T>
struct minQueue {
    std::deque<T> q;
    void pushBack(T x) {
        while (q.size() && x < q.back()) {
            q.pop_back();
        }
        q.push_back(x);
    }
    void popFront(T x) {
        if (q.size() && q.front() == x) {
            q.pop_front();
        }
    }
    T getMinValue() {
        return q.front();
    }
};

template<class T>
struct maxQueue {
    std::deque<T> q;
    void pushBack(T x) {
        while (q.size() && x > q.back()) {
            q.pop_back();
        }
        q.push_back(x);
    }
    void popFront(T x) {
        if (q.size() && q.front() == x) {
            q.pop_front();
        }
    }
    T getMaxValue() {
        return q.front();
    }
};

void solve() {
    int n, k;
    cin >> n >> k;
    
    vector<int> nums(n);
    for (int i = 0; i < n; i++) {
        cin >> nums[i];
    }
    
    minQueue<int> minq;
    for (int i = 0; i < n; i++) {
        minq.pushBack(nums[i]);
        if (i >= k) {
            minq.popFront(nums[i - k]);
        }
        if (i >= k - 1) {
            cout << minq.getMinValue() << " \n"[i == n - 1];
        }
    }
    
    maxQueue<int> maxq;
    for (int i = 0; i < n; i++) {
        maxq.pushBack(nums[i]);
        if (i >= k) {
            maxq.popFront(nums[i - k]);
        }
        if (i >= k - 1) {
            cout << maxq.getMaxValue() << " \n"[i == n - 1];
        }
    }
}

signed main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int T = 1;
//    std::cin >> T;
    while (T--) solve();
    return 0;
}
```

```python
from collections import defaultdict, deque
from typing import List, Tuple
from itertools import combinations, permutations
import math, heapq, queue

II = lambda: int(input())
FI = lambda: float(input())
MII = lambda: tuple(map(int, input().split()))
LII = lambda: list(map(int, input().split()))


def solve() -> None:
    n, k = MII()
    nums = LII()
    
    qa, qb = deque(), deque()
    ra, rb = [], []
    for i in range(n):
        # push back
        while len(qa) and nums[i] < qa[-1]:
            qa.pop()
        qa.append(nums[i])
        while len(qb) and nums[i] > qb[-1]:
            qb.pop()
        qb.append(nums[i])
        if i >= k:
            # pop front
            if len(qa) and qa[0] == nums[i - k]:
                qa.popleft()
            if len(qb) and qb[0] == nums[i - k]:
                qb.popleft()
        if i >= k - 1:
            # get ans
            ra.append(qa[0])
            rb.append(qb[0])
    
    print(' '.join(map(str, ra)))
    print(' '.join(map(str, rb)))


if __name__ == '__main__':
    T = 1
    # T = II()
    while T: solve(); T -= 1
```

## ã€æ¨¡æ¿ã€‘æœ€è¿‘å…¬å…±ç¥–å…ˆ

<https://www.luogu.com.cn/problem/P3379>

> é¢˜æ„ï¼šå¯»æ‰¾æ ‘ä¸­æŒ‡å®šä¸¤ä¸ªç»“ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ $\text{(Lowest Common Ancestor, ç®€ç§° LCA)}$ã€‚
>
> æ€è·¯ï¼šå¯¹äºæ¯æ¬¡æŸ¥è¯¢ï¼Œæˆ‘ä»¬å¯ä»¥ä»æŒ‡å®šçš„ä¸¤ä¸ªç»“ç‚¹å¼€å§‹å¾€ä¸Šè·³ï¼Œç¬¬ä¸€ä¸ªå…¬å…±ç»“ç‚¹å°±æ˜¯ç›®æ ‡çš„ LCAï¼Œæ¯ä¸€æ¬¡è¯¢é—®çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º $O(n)$ï¼Œä¸ºäº†åŠ é€ŸæŸ¥è¯¢ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨å€å¢æ³•ï¼Œé¢„å¤„ç†å‡ºå¾€ä¸Šè·³çš„ç»“æœï¼Œå³ `fa[i][j]` æ•°ç»„ï¼Œè¡¨ç¤º $i$ å·ç‚¹å‘ä¸Šè·³ $2^j$ æ­¥ååˆ°è¾¾çš„ç»“ç‚¹ã€‚æ¥ä¸‹æ¥åœ¨å¾€ä¸Šè·³è·ƒçš„è¿‡ç¨‹ä¸­ï¼Œåˆ©ç”¨äºŒè¿›åˆ¶æ‹¼å‡‘çš„æ€è·¯ï¼Œå³å¯åœ¨ $O(\log n)$ çš„æ—¶é—´å†…æŸ¥è¯¢åˆ° LCAã€‚
>
> é¢„å¤„ç†ï¼šå¯ä»¥å‘ç°ï¼Œå¯¹äº `fa[i][j]`ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡é€’æ¨çš„æ–¹å¼è·å¾—ï¼Œå³ `fa[i][j] = fa[fa[i][j-1]][j-1]`ï¼Œå½“å‰ç»“ç‚¹å‘ä¸Šè·³è·ƒ $2^j$ æ­¥å¯ä»¥æ‹†åˆ†ä¸ºå…ˆå‘ä¸Š $2^{j-1}$ æ­¥, åœ¨æ­¤åŸºç¡€ä¹‹ä¸Šå†å‘ä¸Š $2^{j-1}$ æ­¥.äºæ˜¯æˆ‘ä»¬å¯ä»¥é‡‡ç”¨å®½æœ $or$ æ·±æœçš„é¡ºåºç»´æŠ¤ $fa$ æ•°ç»„ã€‚
>
> è·³è·ƒï¼šæˆ‘ä»¬é¦–å…ˆéœ€è¦å°†ä¸¤ä¸ªç»“ç‚¹æŒ‰ç…§å€å¢çš„æ€è·¯å‘ä¸Šè·³åˆ°åŒä¸€ä¸ªæ·±åº¦ï¼Œæ¥ä¸‹æ¥ä¸¤ä¸ªç»“ç‚¹åŒæ—¶æŒ‰ç…§å€å¢çš„æ€è·¯å‘ä¸Šè·³è·ƒï¼Œä¸ºäº†ç¡®ä¿æ±‚å‡ºæœ€è¿‘çš„ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿åœ¨è·³è·ƒçš„æ­¥è°ƒä¸€è‡´çš„æƒ…å†µä¸‹ï¼Œä¸¤è€…çš„ç¥–å…ˆå§‹ç»ˆä¸ç›¸åŒï¼Œé‚£ä¹ˆå€å¢ç»“æŸåï¼Œä¸¤è€…çš„çˆ¶ç»“ç‚¹å°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œå³ `fa[x][k]` æˆ– `fa[y][k]`
>
> æ—¶é—´å¤æ‚åº¦ï¼š$\Theta(n \log n + m \log n)$ 
>
> - $n \log n$ ä¸ºé¢„å¤„ç†æ¯ä¸€ä¸ªç»“ç‚¹å‘ä¸Šè·³è·ƒæŠµè¾¾çš„æƒ…å†µ
> - $m \log n$ ä¸º $m$ æ¬¡è¯¢é—®çš„æƒ…å†µ

```cpp
const int N = 5e5 + 10;

int n, Q, root;
vector<int> G[N];
int fa[N][20], dep[N];
queue<int> q;

void init() {
    dep[root] = 1;
    q.push(root);

    while (q.size()) {
        int now = q.front();
        q.pop();
        for (int ch: G[now]) {
            if (!dep[ch]) {
                dep[ch] = dep[now] + 1;
                fa[ch][0] = now;
                for (int k = 1; k <= 19; k++) {
                    fa[ch][k] = fa[ fa[ch][k-1] ][k-1];
                }
                q.push(ch);
            }
        }
    }
}

int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);

    // äºŒè¿›åˆ¶æ‹¼å‡‘ä»è€Œè·³åˆ°ä¸€æ ·é«˜
    for (int k = 19; k >= 0; k--)
        if (dep[fa[a][k]] >= dep[b])
            a = fa[a][k];

    if (a == b) return a;

    for (int k = 19; k >= 0; k--)
        if (fa[a][k] != fa[b][k])
            a = fa[a][k], b = fa[b][k];

    return fa[a][0];
}

void solve() {
    cin >> n >> Q >> root;
    for (int i = 0; i < n - 1; ++i) {
        int a, b;
        cin >> a >> b;
        G[a].push_back(b);
        G[b].push_back(a);
    }

    init();

    while (Q--) {
        int a, b;
        cin >> a >> b;
        cout << lca(a, b) << "\n";
    }
}    
```

## ã€æ ˆã€‘éªŒè¯æ ˆåºåˆ—

<https://www.luogu.com.cn/problem/P4387>

> - é¢˜æ„ï¼šç»™å®šå…¥æ ˆåºåˆ—ä¸å‡ºæ ˆåºåˆ—ï¼Œé—®å‡ºæ ˆåºåˆ—æ˜¯å¦åˆæ³•
>
> - æ€è·¯ï¼šæ€è·¯å¾ˆç®€å•ï¼Œå°±æ˜¯å¯¹äºå½“å‰å‡ºæ ˆçš„æ•°ï¼Œå’Œå…¥æ ˆåºåˆ—ä¸­æœ€åå·²å‡ºæ ˆçš„æ•°ä¹‹é—´ï¼Œå¦‚æœè¿˜æœ‰æ•°æ²¡æœ‰å‡ºï¼Œé‚£ä¹ˆå°±æ˜¯ä¸åˆæ³•çš„å‡ºæ ˆåºåˆ—ï¼Œåä¹‹åˆæ³•ã€‚è¿™æ˜¯ä»å…¥æ ˆçš„ç»“æœæ¥çœ‹çš„ï¼Œå¦‚æœè¿™ä¹ˆåˆ¤æ–­å°±éœ€è¦æ‰«æå…¥æ ˆåºåˆ— n æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n^2)$ã€‚æˆ‘ä»¬æŒ‰ç…§å…¥æ ˆçš„é¡ºåºæ¥çœ‹ï¼Œå¯¹äºå½“å‰å¾…å…¥æ ˆçš„æ•°ï¼Œè‹¥ä¸å‡ºæ ˆåºåˆ—çš„é˜Ÿå¤´ä¸ç­‰ï¼Œåˆ™æˆåŠŸå…¥æ ˆç­‰å¾…åç»­å‡ºæ ˆï¼›è‹¥ä¸å‡ºæ ˆåºåˆ—ç›¸ç­‰ï¼Œåˆ™åŒ¹é…æˆåŠŸç›´æ¥å‡ºæ ˆæ— éœ€å…¥æ ˆï¼ŒåŒæ—¶å¯¹å·²å…¥æ ˆçš„æ•°ä¸å‡ºæ ˆåºåˆ—é˜Ÿå¤´ä¸æ–­åŒ¹é…ç›´åˆ°ä¸ç›¸ç­‰ã€‚æœ€ååˆ¤æ–­å¾…å…¥æ ˆçš„æ•°ä¸å‡ºæ ˆåºåˆ—æ˜¯å¦å…¨éƒ¨åŒ¹é…æ‰äº†ï¼Œå¦‚æœå…¨éƒ¨åŒ¹é…æ‰äº†è¯´æ˜è¯¥å‡ºæ ˆåºåˆ—åˆæ³•ï¼Œåä¹‹ä¸åˆæ³•
>
>     æŠ½è±¡æ€»ç»“ä¸Šè¿°æ€è·¯ï¼šä¸ºäº†åˆ¤æ–­å‡ºæ ˆåºåˆ—æ˜¯å¦åˆæ³•ï¼Œæˆ‘ä»¬ä¸å¦¨æ€è€ƒï¼šå¯¹äºæ¯ä¸€ä¸ªå‡ºæ ˆçš„æ•°ï¼Œå‡ºæ ˆçš„æ—¶æœºæ˜¯ä»€ä¹ˆï¼Ÿå¯ä»¥å‘ç°å‡ºæ ˆçš„æ—¶æœºæ— éä¸¤ç§ï¼š
>
>     - ä¸€å…¥æ ˆå°±å‡ºæ ˆï¼ˆå¯¹åº”äºæšä¸¾å¾…å…¥æ ˆåºåˆ—æ—¶å‘ç°å¾…å…¥æ ˆçš„æ•°ä¸å‡ºæ ˆåºåˆ—é˜Ÿå¤´ç›¸ç­‰ï¼‰
>     - ç´§è·Ÿç€åˆšå‡ºæ ˆçš„æ•°ç»§ç»­å‡ºæ ˆï¼ˆå¯¹åº”äºæšä¸¾å¾…å…¥æ ˆåºåˆ—æ—¶å‘ç°å¾…å…¥æ ˆçš„æ•°ä¸å‡ºæ ˆåºåˆ—é˜Ÿå¤´ç›¸ç­‰ä¹‹åï¼Œç»§ç»­åˆ¤æ–­å‡ºæ ˆåºåˆ—é˜Ÿå¤´ä¸å·²å…¥æ ˆçš„æ•°æ˜¯å¦ç›¸ç­‰ï¼Œè‹¥ç›¸ç­‰åˆ™ä¸æ–­åˆ¤æ–­å¹¶å‡ºæ ˆï¼‰
>
> - æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```cpp
// #include <bits/stdc++.h>
// #define int long long
#include <iostream>
#include <unordered_map>
#include <stack>
#include <queue>
using namespace std;

void solve() {
    int n;
    cin >> n;
    
    vector<int> a(n), b(n);
    for (int i = 0; i < n; i++) cin >> a[i];
    for (int i = 0; i < n; i++) cin >> b[i];
    
    stack<int> stk;
    int i = 0, j = 0;
    while (i < n) {
        if (a[i] != b[j]) stk.push(a[i++]);
        else {
            i++, j++;
            while (!stk.empty() && b[j] == stk.top()) {
                stk.pop();
                j++;
            }
        }
    }
    
    cout << (stk.empty() ? "Yes" : "No") << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€äºŒå‰æ ‘ã€‘ç¾å›½è¡€ç»Ÿ

<https://www.luogu.com.cn/problem/P1827>

> é¢˜æ„ï¼šç»™å®šäºŒå‰æ ‘çš„ä¸­åºå’Œå…ˆåºåºåˆ—ï¼Œè¾“å‡ºååºåºåˆ—
>
> æ€è·¯ï¼šç»å…¸äºŒå‰æ ‘çš„é¢˜ç›®ï¼Œä¸»è¦ç”¨äºå·©å›ºåŠ å¼ºå¯¹äºé€’å½’çš„ç†è§£ã€‚æŒ‡é’ˆå…¶å®æ˜¯æ²¡æœ‰å¿…è¦çš„ï¼Œä¸ºäº†å¾—åˆ°ååºåºåˆ—ï¼Œæˆ‘ä»¬åªéœ€è¦æœ‰ä¸€ä¸ª dfs åºå³å¯ï¼Œä¸ºäº†å¾—åˆ° dfs åºï¼Œæˆ‘ä»¬åªéœ€è¦æ ¹æ®ç»™å‡ºçš„ä¸­åºå’Œå‰åºåºåˆ—å³å¯å¾—åˆ° dfs åº
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

æŒ‡é’ˆåšæ³•

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 30;

string mid, pre;

struct Node {
    char data;
    Node* le, * ri;
    Node(char _data) : data(_data), le(nullptr), ri(nullptr) {}
};

Node* build(int i, int j, int p, int q) {
    if (i > j) return nullptr;
    
    Node* root = new Node(pre[i]);
    
    int k; // æ ¹ç»“ç‚¹åœ¨ä¸­åºåºåˆ—çš„ä¸‹æ ‡ 
    for (k = p; k <= q; k++)
        if (mid[k] == root->data)
            break;
    
    root->le = build(i + 1, k - p + i, p, k - 1);
    root->ri = build(k - p + i + 1, j, k + 1, q);
    
    cout << root->data; 
    
    return root;
}

void solve() {
    cin >> mid >> pre;
    
    int i = 0, j = pre.size() - 1;
    int p = 0, q = mid.size() - 1;
    
    build(i, j, p, q);
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

æ„é€ å‡º dfs åºç›´æ¥è¾“å‡º

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 30;

string mid, pre;

// å‰åºèµ·å§‹ iï¼Œå‰åºæœ«å°¾ jï¼Œä¸­åºèµ·å§‹ pï¼Œä¸­åºæœ«å°¾ q 
void build(int i, int j, int p, int q) {
    if (i > j) return;
    
    char root = pre[i];
    
    int k;
    for (k = p; k <= q; k++)
        if (mid[k] == root)
            break;
            
    build(i + 1, k - p + i, p, k - 1);
    build(k - p + i + 1, j, k + 1, q);
    
    cout << root;
} 

void solve() {
    cin >> mid >> pre;
    
    int i = 0, j = pre.size() - 1;
    int p = 0, q = mid.size() - 1;
    
    build(i, j, p, q);
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€äºŒå‰æ ‘ã€‘æ–°äºŒå‰æ ‘

<https://www.luogu.com.cn/problem/P1305>

> é¢˜æ„ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘çš„ n ä¸ªç»“ç‚¹ä¿¡æ¯ï¼Œåˆ†åˆ«ä¸ºå½“å‰ç»“ç‚¹çš„æ•°æ®ä¿¡æ¯ã€å·¦å­©å­ç»“ç‚¹ä¿¡æ¯å’Œå³ç»“ç‚¹ä¿¡æ¯ï¼Œè¾“å‡ºè¿™æ£µäºŒå‰æ ‘çš„å‰åºåºåˆ—
>
> æ€è·¯ï¼šæˆ‘ä»¬é¦–å…ˆå°†è¿™æ£µäºŒå‰æ ‘æ„å»ºå‡ºæ¥ï¼Œæ¥ç€éå†è¾“å‡ºå‰åºåºåˆ—å³å¯ã€‚å…³é”®åœ¨äºå¦‚ä½•æ„å»ºäºŒå‰æ ‘ï¼Ÿæˆ‘ä»¬ä½¿ç”¨æ•°ç»„å­˜å‚¨äºŒå‰æ ‘ï¼Œå¯¹äºæ¯ä¸€ä¸ªæ ‘ä¸Šç»“ç‚¹ï¼Œæˆ‘ä»¬å°†æ•°ç»„ä¸­å…ƒç´ çš„ç´¢å¼•å­˜å‚¨ä¸ºæ ‘ä¸Šç»“ç‚¹ä¿¡æ¯ï¼Œæ¯ä¸€ä¸ªç»“ç‚¹å†å­˜å‚¨å·¦å­©å­ä¸å³å­©å­çš„ä¿¡æ¯
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n;
string s;
char root;

struct Node {
    char l, r;
} tree[200];

void pre(char now) {
    if (now == '*') return;
    cout << now;
    pre(tree[now].l);
    pre(tree[now].r);
}

void solve() {
    cin >> n;
    
    for (int i = 1; i <= n; i++) {
        cin >> s;
        if (i == 1) root = s[0];
        tree[s[0]].l = s[1];
        tree[s[0]].r = s[2];
    }
    
    pre(root);
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€äºŒå‰æ ‘ã€‘éå†é—®é¢˜

<https://www.luogu.com.cn/problem/P1229>

> é¢˜æ„ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘çš„å‰åºåºåˆ—ä¸ååºåºåˆ—ï¼Œé—®ä¸­åºåºåˆ—çš„å¯èƒ½æƒ…å†µæœ‰å¤šå°‘ç§
>
> æ€è·¯ï¼šæˆ‘ä»¬é‡‡ç”¨ä»æœ€å°ç»“æ„å•å…ƒçš„æ€è·¯è¿›è¡Œè€ƒè™‘ï¼Œå³å‡è®¾å½“å‰äºŒå‰æ ‘åªæœ‰ä¸€ä¸ªæ ¹ç»“ç‚¹ä¸ä¸¤ä¸ªå¶å­ç»“ç‚¹ï¼Œè€Œéä¸¤æ£µå­æ ‘ã€‚ç„¶åå°†é¢˜æ„è¿›è¡Œç­‰ä»·å˜æ¢ï¼Œå³é—®å¯¹äºå·²ç»å›ºå®šçš„å‰åºå’ŒååºäºŒå‰æ ‘ï¼Œè¯¥äºŒå‰æ ‘æœ‰å¤šå°‘ç§ä¸åŒçš„å½¢çŠ¶ï¼Ÿå¯¹äºå½“å‰çš„æœ€å°ç»“æ„äºŒå‰æ ‘ï¼Œå½¢çŠ¶å°±æ˜¯ **å·¦å³æ ¹** or **æ ¹å·¦å³**ï¼Œç°åœ¨çš„æ ¹å¯ä»¥ç›´æ¥ç¡®å®šï¼Œé‚£ä¹ˆå°±åªèƒ½ä»å·¦å³å­©å­è¿›è¡Œå˜å½¢ï¼Œå¾ˆæ˜¾ç„¶åªèƒ½è¿›è¡Œå·¦å³äº¤æ¢çš„å˜å½¢ï¼Œä½†æ˜¯é—®é¢˜æ˜¯ä¸€æ—¦å·¦å³å˜æ¢ï¼Œå‰åº or ååºéƒ½ä¼šå˜æ‰ï¼Œè¯´æ˜è¿™ç§å·¦å³å­©å­éƒ½å­˜åœ¨çš„å‰ååºå›ºå®šçš„äºŒå‰æ ‘æ˜¯å”¯ä¸€çš„ï¼Œé‚£ä¹ˆå¦‚ä½•æ‰æ˜¯ä¸å”¯ä¸€çš„å‘¢ï¼Ÿæˆ‘ä»¬è€ƒè™‘å‡å°‘å­©å­æ•°é‡ã€‚å‡è®¾æ²¡æœ‰å­©å­ï¼Œé‚£ä¹ˆå¾ˆæ˜¾ç„¶ä¹Ÿåªæœ‰ä¸€ä¸ªå½¢çŠ¶ï¼Œå°±æ˜¯ä¸€ä¸ªæ ¹ç»“ç‚¹ï¼Œæ•…æ’é™¤ã€‚äºæ˜¯ç­”æ¡ˆå°±å‘¼ä¹‹æ¬²å‡ºäº†ï¼Œå°±æ˜¯å½“æ ¹ç»“ç‚¹åªæœ‰ä¸€ä¸ªå­©å­æ—¶ï¼Œè¿™ä¸ªå­©å­æ— è®ºæ˜¯åœ¨å·¦è¾¹è¿˜æ˜¯å³è¾¹ï¼Œå‰ååºéƒ½æ˜¯ç›¸åŒçš„ï¼Œä½†æ˜¯ä¸­åºåºåˆ—å°±ä¸åŒäº†ï¼Œäºæ˜¯å°±äº§ç”Ÿäº†ä¸¤ç§ä¸­åºåºåˆ—ã€‚äºæ˜¯æœ€ç»ˆçš„ç»“è®ºæ˜¯ï¼šå¯¹äºå‰ååºç¡®å®šçš„äºŒå‰æ ‘æ¥è¯´ï¼Œä¸­åºåºåˆ—çš„æƒ…å†µæ˜¯å°±æ˜¯ $2^{\text{å•åˆ†æ”¯ç»“ç‚¹æ•°}}$ ä¸ªã€‚ç°åœ¨çš„é—®é¢˜å°±è½¬å˜ä¸ºäº†åœ¨ç»™å®šå‰ååºçš„äºŒå‰æ ‘ä¸­æ±‚è§£å•åˆ†æ”¯ç»“ç‚¹ä¸ªæ•°çš„é—®é¢˜ã€‚
>
> å¦‚ä½•å¯»æ‰¾å•åˆ†æ”¯ç»“ç‚¹å‘¢ï¼Ÿæ ¹æ®ä¸‹é¢çš„é€’å½’å›¾å¯ä»¥å‘ç°ï¼Œæ— è®ºæ˜¯å·¦å•åˆ†æ”¯è¿˜æ˜¯å³å•åˆ†æ”¯ï¼Œå¦‚æœ pre çš„è¿ç»­ä¸¤ä¸ªç»“ç‚¹ä¸ post çš„è¿ç»­ä¸¤ä¸ªç»“ç‚¹å¯¹ç§°ç›¸åŒï¼Œé‚£ä¹ˆå°±ä¸€å®šæœ‰ä¸€ä¸ªå•åˆ†æ”¯ç»“ç‚¹ï¼Œæ•…åªéœ€è¦å¯»æ‰¾å‰ååºåºåˆ—ä¸­è¿ç»­ä¸¤ä¸ªå­—ç¬¦å¯¹ç§°ç›¸åŒçš„æƒ…å†µæ•° cnt å³å¯ã€‚æœ€ç»ˆçš„ç­”æ¡ˆæ•°å°±æ˜¯ $2^{cnt}$
>
> ![å›¾ä¾‹](https://cdn.dwj601.cn/images/202406061327025.png)
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(nm)$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

string pre, post;

void solve() {
    cin >> pre >> post;
    
    int cnt = 0;
    
    for (int i = 0; i < pre.size() - 1; i++)
        for (int j = 0; j < post.size(); j++)
            if (pre[i] == post[j + 1] && pre[i + 1] == post[j])
                cnt++;
    
    cout << (1 << cnt) << "\n";
} 

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€äºŒå‰æ ‘ã€‘åŒ»é™¢è®¾ç½®ğŸ˜­

<https://www.luogu.com.cn/problem/P1364>

> é¢˜æ„ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ ‘ä¸­æ¯ä¸€ä¸ªç»“ç‚¹å­˜å‚¨äº†ä¸€ä¸ªæ•°å€¼è¡¨ç¤ºä¸€ä¸ªåŒ»é™¢çš„äººæ•°ï¼Œç°åœ¨éœ€è¦åœ¨æ‰€æœ‰çš„ç»“ç‚¹ä¸­å°†ä¸€ä¸ªç»“ç‚¹è®¾ç½®ä¸ºåŒ»é™¢ä½¿å¾—å…¶ä½™ç»“ç‚¹ä¸­çš„æ‰€æœ‰äººåˆ°è¾¾è¯¥åŒ»é™¢èµ°çš„è·¯æ€»å’Œæœ€å°ã€‚è·¯ç¨‹ä¸ºç»“ç‚¹åˆ°åŒ»é™¢çš„æœ€çŸ­è·¯ï¼Œè¾¹æƒå‡ä¸º 1ã€‚ç»™å‡ºæœ€ç»ˆçš„æœ€çŸ­è·¯å¾„æ€»å’Œ
>
> æ€è·¯ä¸€ï¼šæš´åŠ›
>
> - æ˜¾ç„¶çš„å¯¹äºå·²ç»è®¾ç½®å¥½åŒ»é™¢çš„å±€é¢ï¼Œéœ€è¦æ±‚è§£çš„è·¯å¾„æ€»å’Œå°±ç›´æ¥å°†æ ‘éå†ä¸€è¾¹å³å¯ã€‚æ¯ä¸€ä¸ªç»“ç‚¹éƒ½å¯ä»¥ä½œä¸ºåŒ»é™¢è¿›è¡Œæšä¸¾ï¼Œæ¯æ¬¡éå†æ˜¯ $O(n)$ çš„
>
> - æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$
>
> æ€è·¯äºŒï¼šå¸¦æƒæ ‘çš„é‡å¿ƒ
>
> - TODO
> - æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

æš´åŠ›ä»£ç 

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 110;

int n;

vector<int> G[N];
int cnt[N];

int bfs(int v) {
    int res = 0;
    vector<bool> vis(n + 1, false);
    vector<int> d(n + 1, 0); // d[i] è¡¨ç¤ºç‚¹ i åˆ°ç‚¹ v çš„è·ç¦»
        
    queue<int> q;
    vis[v] = true;
    d[v] = 0;
    q.push(v);
    
    while (q.size()) {
        int now = q.front();
        q.pop();
        
        for (auto& ch: G[now]) {
            if (!vis[ch]) {
                vis[ch] = true;
                d[ch] = d[now] + 1;
                q.push(ch);
                
                res += cnt[ch] * d[ch]; 
            }
        }
    }
    
    return res;
}

void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int count, l, r;
        cin >> count >> l >> r;
        cnt[i] = count;
        
        if (l) {
            G[i].push_back(l);
            G[l].push_back(i);
        }
        
        if (r) {
            G[i].push_back(r);
            G[r].push_back(i);
        }
    }
    
    int res = 1e7 + 10;
    
    for (int i = 1; i <= n; i++) {
        res = min(res, bfs(i));
    }
    
    cout << res << "\n";
} 

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

ä¼˜åŒ–ä»£ç 

```cpp

```

## ã€äºŒå‰æ ‘ã€‘äºŒå‰æ ‘æ·±åº¦

<https://www.luogu.com.cn/problem/P4913>

> é¢˜æ„ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæ±‚è§£è¿™æ£µäºŒå‰æ ‘çš„æ·±åº¦
>
> æ€è·¯ï¼šæœ‰ä¸¤ä¸ªè€ƒç‚¹ï¼Œä¸€ä¸ªæ˜¯å¦‚ä½•æ ¹æ®ç»™å®šçš„ä¿¡æ¯ï¼ˆä»æ ¹ç»“ç‚¹å¼€å§‹ä¾æ¬¡ç»™å‡ºå·²å­˜åœ¨æ ‘ä¸Šç»“ç‚¹çš„å·¦å³å­©å­çš„ç¼–å·ï¼‰æ„å»ºäºŒå‰æ ‘ï¼Œä¸€ä¸ªæ˜¯å¦‚ä½•æ±‚è§£å·²ç»æ„å»ºå¥½çš„äºŒå‰æ ‘çš„æ·±åº¦ã€‚å¯¹äºæ„å»ºäºŒå‰æ ‘ï¼Œæˆ‘ä»¬æ²¿ç”¨ T5 æ•°ç»„æ¨¡æ‹Ÿæ„å»ºçš„æ€è·¯ï¼Œç›´æ¥å®šä¹‰ç»“ç‚¹ç±»å‹å³å¯ï¼›å¯¹äºæ±‚è§£æ·±åº¦ï¼Œå¾ˆæ˜¾ç„¶çš„ä¸€ä¸ªé€’å½’æ±‚è§£ï¼Œå³å·¦å³å­æ ‘æ·±åº¦å€¼ +1 å³å¯
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1000010;

int n;

struct Node {
    int l, r;
} t[N];

int dep(int now) {
    if (!now) return 0;
    return max(dep(t[now].l), dep(t[now].r)) + 1;
}

void solve() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x, y;
        cin >> x >> y;
        t[i].l = x, t[i].r = y;
    }
    
    cout << dep(1);
} 

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€å®Œå…¨äºŒå‰æ ‘ã€‘æ·˜æ±°èµ›

<https://www.luogu.com.cn/problem/P1364>

> é¢˜æ„ï¼šç»™å®š $2^n$ æ”¯çƒé˜Ÿçš„ç¼–å·ä¸èƒ½åŠ›å€¼ï¼Œè¿›è¡Œæ·˜æ±°èµ›ï¼Œèƒ½åŠ›å€¼è€…æ™‹çº§ä¸‹ä¸€è½®ç›´åˆ°èµ›å‡ºå† å†›ã€‚è¾“å‡ºäºšå†›ç¼–å·
>
> æ€è·¯ï¼šå¾ˆæ˜¾ç„¶çš„ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘çš„é¢˜ç›®ã€‚æˆ‘ä»¬éƒ½ä¸éœ€è¦è¿›è¡Œé€’å½’æ“ä½œï¼Œç›´æ¥åˆ©ç”¨å®Œå…¨äºŒå‰æ ‘çš„ä¸‹æ ‡æ€§è´¨åˆ©ç”¨æ•°ç»„æ¨¡æ‹Ÿå¾ªç¯è®¡ç®—å³å¯ã€‚ç»™å‡ºçš„ä¿¡æ¯å°±æ˜¯å®Œå…¨äºŒå‰æ ‘çš„å…¨éƒ¨å¶å­ç»“ç‚¹çš„ä¿¡æ¯ï¼Œåˆ†åˆ«ä¸ºçƒé˜Ÿç¼–å· id ä¸çƒé˜Ÿèƒ½åŠ›å€¼ valï¼Œæˆ‘ä»¬ä»ç¬¬ n-1 ä¸ªç»“ç‚¹å¼€å§‹å¾ªç¯æšä¸¾åˆ°ç¬¬ 1 ä¸ªç»“ç‚¹è®¡ç®—æ¯ä¸€è½®çš„èƒœè€…ä¿¡æ¯ï¼Œæœ€ç»ˆè¾“å‡ºæœ€åä¸€åœºçš„èƒ½åŠ›å€¼è¾ƒå°è€…çƒé˜Ÿç¼–å·å³å¯
>
> æ—¶é—´å¤æ‚åº¦ï¼š$\Theta(2n)$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1 << 8;

struct Node {
    int id, val;
} a[N];

int n;

void solve() {
    cin >> n;
    
    n = 1 << n;
    
    for (int i = n; i <= 2 * n - 1; i++) {
        a[i].id = i - n + 1;
        cin >> a[i].val;
    }
    
    for (int i = n - 1; i >= 1; i--)
        if (a[i * 2].val > a[i * 2 + 1].val) a[i] = a[i * 2];
        else a[i] = a[i * 2 + 1];
            
    if (a[2].val > a[3].val) cout << a[3].id;
    else cout << a[2].id;
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€äºŒå‰æ ‘/LCAã€‘äºŒå‰æ ‘é—®é¢˜

<https://www.luogu.com.cn/problem/P3884>

> é¢˜æ„ï¼šç»™å®šä¸€æ£µäºŒå‰æ ‘çš„ç»“ç‚¹å…³ç³»ä¿¡æ¯ï¼Œæ±‚å‡ºè¿™æ£µäºŒå‰æ ‘çš„æ·±åº¦ã€å®½åº¦å’Œä¸¤ä¸ªæŒ‡å®šç»“ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„é•¿åº¦
>
> æ€è·¯ï¼šäºŒå‰æ ‘çš„æ„å»ºç›´æ¥é‡‡ç”¨æœ‰å‘å›¾çš„æ„é€ æ–¹æ³•ã€‚æ·±åº¦ç›´æ¥ dfs å³å¯ï¼Œå®½åº¦ç›´æ¥åœ¨ dfs éå†æ—¶å“ˆå¸Œæ·±åº¦å€¼å³å¯ã€‚é—®é¢˜çš„å…³é”®åœ¨äºå¦‚ä½•æ±‚è§£ä¸¤ä¸ªç»™å®šç»“ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ï¼Œå¾ˆæ˜¾ç„¶éœ€è¦æ±‚è§£ä¸¤ä¸ªç»“ç‚¹çš„ LCAï¼Œç”±äºç»“ç‚¹æ•° $\le 100$ æ•…ç›´æ¥é‡‡ç”¨æš´åŠ›çš„æ–¹æ³•ï¼Œå¯ä»¥é‡å®šä¹‰ç»“ç‚¹ï¼Œå¢åŠ çˆ¶ç»“ç‚¹åŸŸã€‚ä¹Ÿå¯ä»¥é€šè¿‡æ¯”å¯¹æ ¹ç»“ç‚¹åˆ°ä¸¤ä¸ªæŒ‡å®šç»“ç‚¹çš„è·¯å¾„ä¿¡æ¯å¾—åˆ° LCA å³æœ€åä¸€ä¸ªç›¸åŒçš„ç»“ç‚¹ç¼–å·ï¼ˆæœ¬é¢˜é‡‡ç”¨ï¼‰ï¼Œé€šè¿‡åœ¨ dfs éå†æ ‘æ—¶å­˜å‚¨è·¯å¾„å³å¯å¾—åˆ°æ ¹ç»“ç‚¹åˆ°ä¸¤ä¸ªæŒ‡å®šç»“ç‚¹çš„è·¯å¾„ä¿¡æ¯ã€‚ä¹‹åç›´æ¥æ ¹æ®é¢˜ä¸­æ–°å®šä¹‰çš„è·¯å¾„é•¿åº¦è¾“å‡ºå³å¯ï¼Œå³
> $$
> \text{length} = 2 \times (d_x - d_{lca}) + (d_y - d_{lca})
> $$
> å…¶ä¸­ $d_i$ è¡¨ç¤ºï¼šæ ¹ç»“ç‚¹åˆ°ç¬¬ $i$ å·ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ï¼Œåœ¨ dfs æ—¶é€šè¿‡ä¼ é€’æ·±åº¦å€¼ç»´æŠ¤å¾—åˆ°
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 110;

int n, x, y;
vector<int> G[N];
int depth, width;
unordered_map<int, int> ha; // å°†æ‰€æœ‰çš„æ·±åº¦å€¼è¿›è¡Œå“ˆå¸Œ
int d[N];                   // d[i] è¡¨ç¤ºç¬¬ i ä¸ªç‚¹åˆ°æ ¹ç»“ç‚¹çš„è¾¹æ•°
vector<int> temp, rx, ry;   // æ ¹ç»“ç‚¹åˆ° x å·ç‚¹ä¸ y å·ç‚¹ç›´æ¥çš„è·¯å¾„ç»“ç‚¹ç¼–å·

// å½“å‰ç»“ç‚¹ç¼–å· nowï¼Œå½“å‰æ·±åº¦ level
void dfs(int now, int level) {
    depth = max(depth, level);
    
    temp.push_back(now);
    if (now == x) rx = temp;
    if (now == y) ry = temp;
    
    ha[level]++;
    d[now] = level - 1;
    
    for (auto& ch: G[now]) {
        dfs(ch, level + 1);
        temp.pop_back();
    }
}

// æš´åŠ› lca + è®¡ç®—è·¯å¾„é•¿åº¦
int len(int x, int y) {
    int i = 0;
    while (i < rx.size() && i < ry.size() && rx[i] == ry[i]) i++;
    
    int lca = rx[--i];
    
    return 2 * (d[x] - d[lca]) + (d[y] - d[lca]);
}

void solve() {
    cin >> n;
    
    for (int i = 1; i <= n - 1; i++) {
        int a, b;
        cin >> a >> b;
        G[a].push_back(b);
    }
    
    cin >> x >> y;
    
    // äºŒå‰æ ‘çš„æ·±åº¦ depth
    dfs(1, 1);
    cout << depth << "\n";
    
    // äºŒå‰æ ‘çš„å®½åº¦ width
    for (auto& item: ha) width = max(width, item.second);
    cout << width << "\n";
    
    // ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦
    cout << len(x, y) << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€setã€‘è¥ä¸šé¢ç»Ÿè®¡

<https://www.luogu.com.cn/problem/P2234>

> é¢˜æ„ï¼šç»™å®šä¸€ä¸ªåºåˆ— aï¼Œéœ€è¦è®¡ç®— $a_1 + \displaystyle \sum_{i=2,1 \le j <i}^{n} \min {|a_i - a_j|}$ ï¼Œå³è®¡ç®—æ¯ä¸€ä¸ªæ•°ä¸åºåˆ—ä¸­å½“å‰æ•°ä¹‹å‰çš„æ•°çš„æœ€å°å·®å€¼ä¹‹å’Œ
>
> æ€è·¯ï¼šå¾ˆæ˜¾ç„¶çš„æ€è·¯ï¼Œå¯¹äºæ¯ä¸€ä¸ªæ•°ï¼Œæˆ‘ä»¬éœ€è¦å¯¹ä¹‹å‰çš„åºåˆ—åœ¨çŸ­æ—¶é—´å†…æ‰¾åˆ°ä¸€ä¸ªæ•°å€¼æœ€æ¥è¿‘å½“å‰æ•°çš„æ•°ã€‚
> - TLEï¼šä¸€å¼€å§‹çš„æ€è·¯æ˜¯æ¯æ¬¡å¯¹ä¹‹å‰çš„åºåˆ—è¿›è¡Œæ’åºï¼Œç„¶åäºŒåˆ†æŸ¥æ‰¾ä¸å½“å‰å€¼åŒ¹é…çš„æ•°ï¼Œä¸ºäº†ç¡®ä¿æ‰€æœ‰çš„æƒ…å†µéƒ½æ‰¾åˆ°ï¼Œå°±ç›´æ¥åˆ¤æ–­äºŒåˆ†æŸ¥åˆ°çš„æ•°ï¼ŒæŸ¥åˆ°çš„æ•°ä¹‹å‰çš„ä¸€ä¸ªæ•°ï¼Œä¹‹åçš„ä¸€ä¸ªæ•°ï¼Œä½†æ˜¯æ—¶é—´å¤æ‚åº¦æé«˜ï¼ˆæˆ‘å±…ç„¶æ²¡æƒ³åˆ°ï¼‰ï¼Œæ˜¯ $O(n^2 \log n)$
> - ACï¼šåæ¥çœ‹äº†é¢˜è§£æ‰çŸ¥é“ `set` çš„æ­£ç¡®ç”¨æ³•ï¼Œå°±æ˜¯ä¸€ä¸ª **å¹³è¡¡æ ‘çš„ STL**ã€‚æˆ‘ä»¬å¯¹äºä¹‹å‰çš„åºåˆ—ä¸æ–­çš„æ’å…¥å¹³è¡¡æ ‘ä¸­ï¼ˆé»˜è®¤å‡åºæ’åºï¼‰ï¼Œæ¯æ¬¡åˆ©ç”¨ `s.lower_bound(x)` è¿”å›ã€Œé›†åˆ `s` ä¸­ç¬¬ä¸€ä¸ª $\ge$ å½“å‰æ•°çš„è¿­ä»£å™¨ã€ï¼Œç„¶åè¿›è¡Œåˆ¤æ–­å³å¯ã€‚`lower_bound()` çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(\log n)$ ã€‚éœ€è¦æ³¨æ„çš„æ˜¯è¾¹ç•Œçš„åˆ¤æ–­ï¼Œä¸€å¼€å§‹çš„æ€è·¯è™½ç„¶ä¼šè¶…æ—¶ï¼Œä½†æ˜¯äºŒåˆ†åè¾¹ç•Œçš„åˆ¤æ–­å¾ˆç®€å•ï¼Œä½¿ç”¨ STL ååŒæ ·éœ€è¦è€ƒè™‘è¾¹ç•Œçš„æƒ…å†µã€‚åˆ†ä¸ºä¸‰ç§ï¼ˆè¯¦æƒ…è§ä»£ç ï¼‰
>     - å½“å‰æ•°æ¯”é›†åˆä¸­æ‰€æœ‰çš„æ•°éƒ½å¤§ï¼Œé‚£ä¹ˆ `lower_bound` å°±ä¼šè¿”å› `s.end()` ç­”æ¡ˆå°±æ˜¯å½“å‰æ•°ä¸é›†åˆä¸­æœ€åä¸€ä¸ªæ•°çš„å·®å€¼
>     - å½“å‰æ•°æ¯”é›†åˆä¸­æ‰€æœ‰çš„æ•°éƒ½å°ï¼Œé‚£ä¹ˆ `lower_bound` å°±ä¼šè¿”å› `s.bigin()` ç­”æ¡ˆå°±æ˜¯é›†åˆä¸­ç¬¬ä¸€ä¸ªæ•°ä¸å½“å‰æ•°çš„å·®å€¼
>     - å½“å‰æ•°å­˜åœ¨äºé›†åˆä¸­ or é›†åˆä¸­æ—¢æœ‰æ¯”å½“å‰æ•°å¤§çš„åˆæœ‰æ¯”å½“å‰æ•°å°çš„ï¼Œé‚£ä¹ˆå°±æ¯”è¾ƒæŸ¥åˆ°çš„æ•°ä¸æŸ¥åˆ°çš„æ•°å‰ä¸€ä¸ªæ•°å’Œå½“å‰æ•°çš„å·®å€¼ï¼Œå–æœ€å°çš„å·®å€¼å³å¯
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log n)$

TLE ä½†é€»è¾‘æ¸…æ™°ä»£ç 

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1 << 16;

int n, a[N];

void solve() {
    cin >> n;
    
    int res = 0;
    cin >> a[1];
    res += a[1];
    
    for (int i = 2; i <= n; i++) {
        // ç»´æŠ¤ä¹‹å‰åºåˆ—æœ‰åº
        sort(a + 1, a + i);
        cin >> a[i];

        // äºŒåˆ†æŸ¥æ‰¾ç›®æ ‡æ•°
        int l = 1, r = i - 1;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (a[mid] < a[i]) l = mid + 1;
            else r = mid;
        }
        
        // è¾¹ç•Œåˆ¤æ–­
        int ans = abs(a[i] - a[r]);
        if (r + 1 >= 1 && r + 1 <= i - 1) ans = min(ans, abs(a[i] - a[r + 1]));
        if (r - 1 >= 1 && r - 1 <= i - 1) ans = min(ans, abs(a[i] - a[r - 1]));
        
        res += ans;
    }
    
    cout << res << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

AC çš„ set ä»£ç 

```cpp
#include <iostream>
#include <algorithm>
#include <set>
using namespace std;

int n, res;
set<int> s;

void solve() {
    cin >> n;
    
    int x;
    cin >> x;
    res += x;
    s.insert(x);
    
    while (--n) {
        cin >> x;

        auto it = s.lower_bound(x);

        if (it == s.end()) {
            // æ²¡æœ‰æ¯”å½“å‰æ•°å¤§çš„
            res += x - *s.rbegin();
        } else if (it == s.begin()) {
            // æ²¡æœ‰æ¯”å½“å‰æ•°å°çš„
            res += *s.begin() - x;
        } else {
            // å½“å‰æ•°å·²å­˜åœ¨äºé›†åˆä¸­ or æ—¢æœ‰æ¯”å½“å‰æ•°å¤§çš„ä¹Ÿæœ‰æ¯”å½“å‰æ•°å°çš„
            auto pre = it;
            pre--;
            res += min(abs(x - *it), abs(x - *pre));
        }
        
        s.insert(x);
    }
    
    cout << res << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€multisetã€‘åˆ‡è›‹ç³•

<https://www.acwing.com/problem/content/description/5581/>

> é¢˜æ„ï¼šç»™å®šä¸€ä¸ªçŸ©å½¢ï¼Œç”±å·¦ä¸‹è§’å’Œå³ä¸Šè§’çš„åæ ‡ç¡®å®šã€‚ç°åœ¨å¯¹è¿™ä¸ªçŸ©å½¢è¿›è¡Œåˆ‡å‰²æ“ä½œï¼Œè¦ä¹ˆç«–ç€åˆ‡ï¼Œè¦ä¹ˆæ¨ªç€åˆ‡ã€‚ç°åœ¨éœ€è¦ç»™å‡ºæ¯æ¬¡åˆ‡å‰²åæœ€å¤§å­çŸ©å½¢çš„é¢ç§¯
>
> æ€è·¯ï¼šSTL setã€‚å¾ˆå®¹æ˜“æƒ³åˆ°ï¼Œæ¨ªçºµåæ ‡æ˜¯ç›¸äº’ç‹¬ç«‹çš„ï¼Œæœ€å¤§å­çŸ©å½¢é¢ç§¯ä¸€å®šäº§ç”Ÿäºæœ€å¤§é•¿åº¦ä¸æœ€å¤§å®½åº¦çš„ä¹˜ç§¯ã€‚å› æ­¤æˆ‘ä»¬åªéœ€è¦ç»´æŠ¤ä¸€ä¸ªåºåˆ—çš„æœ€å¤§å€¼å³å¯ã€‚å¯¹äºäºŒç»´å¯ä»¥ç›´æ¥å½“åšä¸€ç»´æ¥çœ‹ï¼Œäºæ˜¯é—®é¢˜å°±å˜æˆäº†ï¼Œéœ€è¦åœ¨ $\log n$ çš„æ—¶é—´å¤æ‚åº¦å†…ï¼Œå¯¹ä¸€ä¸ªåºåˆ—å®Œæˆä¸‹é¢ä¸‰ä¸ªæ“ä½œï¼š
>
> 1. åˆ é™¤ä¸€ä¸ªæ•°
> 2. å¢åŠ ä¸€ä¸ªæ•°ï¼ˆæ‰§è¡Œä¸¤æ¬¡ï¼‰
> 3. è·å–æœ€å¤§å€¼
>
> å¦‚ä½•å®ç°å‘¢ï¼Ÿæˆ‘ä»¬éœ€è¦æœ‰åºè®°å½•æ¯ä¸€ä¸ªå­çº¿æ®µçš„é•¿åº¦ï¼Œå¹¶ä¸”å­çº¿æ®µçš„é•¿åº¦å¯èƒ½é‡å¤ï¼Œå› æ­¤æˆ‘ä»¬ç”¨ `std::multiset` æ¥å­˜å‚¨æ‰€æœ‰å­çº¿æ®µçš„é•¿åº¦
>
> 1. ä½¿ç”¨ `M.erase(M.find(value))` å®ç°ï¼šåˆ é™¤ä¸€ä¸ªå­çº¿æ®µé•¿åº¦å€¼
> 2. ä½¿ç”¨ `M.insert(value)` å®ç°ï¼šå¢åŠ å­çº¿æ®µä¸€ä¸ªé•¿åº¦å€¼
> 3. ä½¿ç”¨ `*M.rbegin()` å®ç°ï¼šè·å–å½“å‰æ‰€æœ‰å­çº¿æ®µé•¿åº¦çš„æœ€å¤§å€¼
>
> ç”±äºç»™çš„æ˜¯åˆ‡å‰²çš„ä½ç½®åæ ‡ `x`ï¼Œå› æ­¤ä¸Šè¿°æ“ä½œ 1 ä¸èƒ½ç›´æ¥å®ç°ï¼Œæˆ‘ä»¬éœ€è¦åˆ©ç”¨ç»™å®šçš„åˆ‡å‰²åæ ‡ `x` è®¡ç®—å‡ºå½“å‰åˆ‡å‰²ä½ç½®å¯¹åº”å­çº¿æ®µçš„é•¿åº¦ã€‚å¦‚ä½•å®ç°å‘¢ï¼Ÿæˆ‘ä»¬çŸ¥é“ï¼Œå¯¹äºå½“å‰åˆ‡å‰²çš„åæ ‡ `x`ï¼Œå¯¹åº”çš„å­çº¿æ®µçš„é•¿åº¦å–å†³äºå½“å‰åˆ‡å‰²åæ ‡å·¦å³ä¸¤ä¸ªåˆ‡å‰²çš„ä½ç½® `rp, lp`ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦å­˜å‚¨æ¯ä¸€ä¸ªåˆ‡å‰²çš„åæ ‡å³å¯ã€‚ç”±äºåˆ‡å‰²ä½ç½®ä¸ä¼šé‡å¤ï¼Œå¹¶ä¸”éœ€è¦åœ¨ $\log n$ çš„æ—¶é—´å¤æ‚åº¦å†…æŸ¥è¯¢åˆ°ï¼Œå› æ­¤æˆ‘ä»¬è¿˜æ˜¯å¯ä»¥ä½¿ç”¨ `std::set` æ¥å­˜å‚¨åˆ‡å‰²ä½ç½®
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log n)$

```cpp
#include <iostream>
#include <set>
using namespace std;
using ll = long long;

void work(int x, set<int>& S, multiset<int>& M) {
    set<int>::iterator rp = S.upper_bound(x), lp = rp;
    lp--;
    S.insert(x);

    M.erase(M.find(*rp - *lp));
    M.insert(*rp - x);
    M.insert(x - *lp);
}

void solve() {
    int w, h, n;
    cin >> w >> h >> n;

    set<int> S1, S2;
    multiset<int> M1, M2;
    S1.insert(0), S1.insert(w), M1.insert(w);
    S2.insert(0), S2.insert(h), M2.insert(h);

    while (n--) {
        char op;
        int x;
        cin >> op >> x;
        if (op == 'X') work(x, S1, M1);
        else work(x, S2, M2);

        cout << (ll)*M1.rbegin() * *M2.rbegin() << "\n";
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€å¹¶æŸ¥é›†ã€‘Milk Visits S

<https://www.luogu.com.cn/problem/P5836>

> é¢˜æ„ï¼šç»™å®šä¸€æ£µæ ‘ï¼Œç»“ç‚¹è¢«æ ‡è®°æˆä¸¤ç§ï¼Œä¸€ç§æ˜¯ Hï¼Œä¸€ç§æ˜¯ Gï¼Œåœ¨æ¯ä¸€æ¬¡æŸ¥è¯¢ä¸­ï¼Œéœ€è¦çŸ¥é“æŒ‡å®šçš„ä¸¤ä¸ªç»“ç‚¹ä¹‹é—´æ˜¯å¦å«æœ‰æŸä¸€ç§æ ‡è®°
>
> æ€è·¯ï¼šå¯¹äºæ ‘ä¸Šæ ‡è®°ï¼Œæˆ‘ä»¬å¯ä»¥å°†ç›¸åŒé¢œè‰²çš„åˆ†æ”¯è¿æˆä¸€ä¸ªè¿é€šå—
>
> - å¦‚æœæŸ¥è¯¢çš„ä¸¤ä¸ªç»“ç‚¹åœ¨åŒä¸€ä¸ªè¿é€šå—ï¼Œåˆ™æŸ¥è¯¢ä¸¤ä¸ªç»“ç‚¹æ‰€åœ¨çš„é¢œè‰²ä¸æ‰€éœ€çš„é¢œè‰²æ˜¯å¦åŒ¹é…å³å¯
> - å¦‚æœæŸ¥è¯¢çš„ä¸¤ä¸ªç»“ç‚¹ä¸åœ¨åŒä¸€ä¸ªè¿é€šå—ï¼Œä¸¤ä¸ªç»“ç‚¹ä¹‹é—´çš„è·¯å¾„ä¸€å®šæ˜¯è¦†ç›–äº†ä¸¤ç§é¢œè‰²çš„æ ‡è®°ï¼Œåˆ™ç­”æ¡ˆä¸€å®šæ˜¯ 1
>
> æ—¶é—´å¤æ‚åº¦ï¼š$\Theta(n+m)$

```cpp
const int N = 100010;

int n, m, p[N];
char col[N];

int find(int x) {
    if (p[x] != x) {
        p[x] = find(p[x]);
    }
    return p[x];
}

void solve() {
    cin >> n >> m;
    cin >> (col + 1);

    for (int i = 1; i <= n; i++) {
        p[i] = i;
    }

    for (int i = 1; i <= n - 1; i++) {
        int a, b;
        cin >> a >> b;
        if (col[a] == col[b]) {
            p[find(a)] = find(b);
        }
    }

    string res;

    while (m--) {
        int u, v;
        cin >> u >> v;

        char cow;
        cin >> cow;

        if (find(u) == find(v)) {
            res += to_string(col[u] == cow);
        } else {
            res += '1';
        }
    }

    cout << res << "\n";
}
```

## ã€å¹¶æŸ¥é›†ã€‘å°½é‡å‡å°‘æ¶æ„è½¯ä»¶çš„ä¼ æ’­

<https://leetcode.cn/problems/minimize-malware-spread/description/>

>é¢˜æ„ï¼šç»™å®šä¸€ä¸ªç”±é‚»æ¥çŸ©é˜µå­˜å‚¨çš„æ— å‘å›¾ï¼Œå…¶ä¸­æŸäº›ç»“ç‚¹å…·å¤‡æ„ŸæŸ“èƒ½åŠ›ï¼Œå¯ä»¥æ„ŸæŸ“ç›¸è¿çš„æ‰€æœ‰ç»“ç‚¹ï¼Œé—®æ¶ˆé™¤å“ªä¸€ä¸ªç»“ç‚¹çš„æ„ŸæŸ“èƒ½åŠ›å¯ä»¥ä½¿å¾—æœ€ç»ˆä¸è¢«æ„ŸæŸ“çš„ç»“ç‚¹æ•°é‡å°½å¯èƒ½å°‘ï¼Œç»™å‡ºæ¶ˆé™¤çš„æœ‰æ„ŸæŸ“èƒ½åŠ›çš„æœ€å°ç»“ç‚¹ç¼–å·
>
>æ€è·¯ï¼šå¾ˆæ˜¾ç„¶æˆ‘ä»¬å¯ä»¥å°†å½“å‰æ— å‘å›¾çš„å¤šä¸ªè¿é€šåˆ†é‡ï¼Œå…±ä¸‰ç§æ„ŸæŸ“æƒ…å†µï¼š
>
>1. å¦‚æœä¸€ä¸ªè¿é€šåˆ†é‡ä¸­å«æœ‰ $\ge 2$ ä¸ªæ„ŸæŸ“ç»“ç‚¹ï¼Œåˆ™å½“å‰è¿é€šåˆ†é‡ä¸€å®šä¼šè¢«å…¨éƒ¨æ„ŸæŸ“ï¼›
>
>2. å¦‚æœä¸€ä¸ªè¿é€šå—ä¸­å«æœ‰ $0$ ä¸ªæ„ŸæŸ“ç»“ç‚¹ï¼Œåˆ™æ— éœ€ä»»ä½•æ“ä½œï¼›
>
>3. å¦‚æœä¸€ä¸ªè¿é€šå—ä¸­å«æœ‰ $1$ ä¸ªæ„ŸæŸ“ç»“ç‚¹ï¼Œåˆ™æœ€ä½³å®è·µå°±æ˜¯ç§»é™¤è¯¥è¿é€šå—ä¸­å”¯ä¸€çš„é‚£ä¸ªæ„ŸæŸ“ç»“ç‚¹ã€‚
>
>å½“ç„¶äº†ï¼Œç”±äºåªèƒ½ç§»èµ°ä¸€ä¸ªæ„ŸæŸ“ç»“ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦ä»æ‰€æœ‰åªå«æœ‰ $1$ ä¸ªæ„ŸæŸ“ç»“ç‚¹çš„è¿é€šå—ä¸­ç§»èµ°è¿é€šå—ç»“ç‚¹æœ€å¤šçš„é‚£ä¸ªæ„ŸæŸ“ç»“ç‚¹ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦ç»Ÿè®¡æ¯ä¸€ä¸ªè¿é€šåˆ†é‡ä¸­æ„ŸæŸ“ç»“ç‚¹çš„æ•°é‡ä»¥åŠæ€»ç»“ç‚¹æ•°ï¼Œé‡‡ç”¨å¹¶æŸ¥é›†è¿›è¡Œç»Ÿè®¡ã€‚éœ€è¦æ³¨æ„çš„æ˜¯é¢˜ç›®ä¸­çš„â€œç´¢å¼•æœ€å°â€æŒ‡çš„æ˜¯ç»“ç‚¹ç¼–å·æœ€å°è€Œéç»“ç‚¹åœ¨åºåˆ— $initial$ ä¸­çš„ä¸‹æ ‡æœ€å°ã€‚ç®—æ³•æµç¨‹è§ä»£ç ã€‚
>
>æ—¶é—´å¤æ‚åº¦ï¼š$O(n^2)$

```cpp
class Solution {
public:
    int p[310];

    int Find(int x) {
        if (x != p[x]) p[x] = Find(p[x]);
        return p[x];
    }

    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // 1. ç»´æŠ¤å¹¶æŸ¥é›†æ•°ç»„ï¼šp[]
        int n = graph.size();
        for (int i = 0; i < n; i++) p[i] = i;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                if (graph[i][j])
                    p[Find(i)] = Find(j);

        // 2. ç»´æŠ¤å“ˆå¸Œè¡¨ï¼šæ¯ä¸€ä¸ªè¿é€šå—ä¸­çš„æ„ŸæŸ“ç»“ç‚¹æ•°ã€æ€»ç»“ç‚¹æ•°
        unordered_map<int, pair<int, int>> ha;
        for (auto& x: initial) ha[Find(x)].first++;
        for (int i = 0; i < n; i++) ha[Find(i)].second++;

        // 3. æ’åºï¼šæŒ‰ç…§æ„ŸæŸ“ç»“ç‚¹æ•°å‡åºï¼Œæ€»ç»“ç‚¹æ•°é™åº
        vector<pair<int, int>> v;
        for (auto& it: ha) v.push_back(it.second);
        sort(v.begin(), v.end(), [&](pair<int, int>& x, pair<int, int>& y){
            if (x.first == y.first) return x.second > y.second;
            return x.first < y.first;
        });

        // 4. å¯»æ‰¾ç¬¦åˆæ¡ä»¶çš„è¿é€šå—å±æ€§ï¼šæ‰¾åˆ°åºåˆ—ä¸­ç¬¬ä¸€ä¸ªå«æœ‰ 1 ä¸ªæ„ŸæŸ“ç»“ç‚¹çš„è¿é€šå—ç¥–å®—ç»“ç‚¹ç¼–å· idx
        int idx = -1;
        for (int i = 0; i < v.size(); i++) {
            if (v[i].first == 1) {
                idx = i;
                break;
            }
        }

        // 5. è¿”å›ç­”æ¡ˆï¼šæ¯”å¯¹æ„ŸæŸ“ç»“ç‚¹æ‰€åœ¨çš„è¿é€šå—å±æ€§ä¸ç›®æ ‡è¿é€šå—å±æ€§
        if (idx == -1) {
            // ç‰¹åˆ¤æ²¡æœ‰è¿é€šå—åªå«æœ‰ 1 ä¸ªæ„ŸæŸ“ç»“ç‚¹çš„æƒ…å†µ
            return *min_element(initial.begin(), initial.end());
        }
        
        int res = n + 10;
        for (auto& x: initial) {
            int px = Find(x);
            if (ha[px].first == v[idx].first && ha[px].second == v[idx].second) {
                res = min(res, x);
            }
        }

        return res;
    }
};
```

## ã€å¹¶æŸ¥é›†ã€‘è´¦æˆ·åˆå¹¶

<https://leetcode.cn/problems/accounts-merge/>

> é¢˜æ„ï¼šç»™å®š n ä¸ªè´¦æˆ·ï¼Œæ¯ä¸€ä¸ªè´¦æˆ·å«æœ‰ä¸€ä¸ªç”¨æˆ·åå’Œæœ€å¤š m ä¸ªç»‘å®šçš„é‚®ç®±ã€‚ç”±äºä¸€ä¸ªç”¨æˆ·å¯èƒ½æ³¨å†Œå¤šä¸ªè´¦æˆ·ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¯¹æ‰€æœ‰çš„è´¦æˆ·è¿›è¡Œåˆå¹¶ä½¿å¾—ä¸€ä¸ªç”¨æˆ·å¯¹åº”ä¸€ä¸ªè´¦æˆ·ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯å°†æ‰€æœ‰ã€Œå«æœ‰ç›¸åŒé‚®ç®±çš„è´¦æˆ·ã€è§†ä½œåŒä¸€ä¸ªç”¨æˆ·æ³¨å†Œçš„è´¦æˆ·ã€‚è¿”å›åˆå¹¶åçš„è´¦æˆ·åˆ—è¡¨ã€‚
>
> æ€è·¯ï¼šè¿™é“é¢˜çš„éœ€æ±‚å¾ˆæ˜¾ç„¶ï¼Œæˆ‘ä»¬éœ€è¦åˆå¹¶å«æœ‰ç›¸åŒé‚®ç®±çš„è´¦æˆ·ã€‚æ˜¾ç„¶æœ‰ä¸€ä¸ªæš´åŠ›çš„åšæ³•ï¼Œæˆ‘ä»¬ç›´æ¥æšä¸¾æ¯ä¸€ä¸ªè´¦æˆ·ä¸­æ‰€æœ‰çš„é‚®ç®±ï¼Œæ¥ç€æšä¸¾å‰©ä½™è´¦æˆ·ä¸­çš„é‚®ç®±è¿›è¡ŒåŒ¹é…ï¼ŒåŒ¹é…ä¸Šå°±è¿›è¡Œåˆå¹¶ï¼Œä½†è¿™æ ·åšæ˜¾ç„¶ä¼šé€ æˆå¤§é‡çš„å†—ä½™åŒ¹é…å’Œå†—ä½™åˆå¹¶ï¼Œæˆ‘ä»¬ä¸å¦¨å°†è¿™ä¸¤ä¸ªè¿‡ç¨‹è¿›è¡Œæ‹†åˆ†ã€‚æˆ‘ä»¬éœ€è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼š
>
> - å“ªäº›è´¦æˆ·éœ€è¦åˆå¹¶ï¼Ÿå¾ˆå®¹æ˜“æƒ³åˆ°å¹¶æŸ¥é›†è¿™æ ·çš„æ•°æ®ç»“æ„ã€‚æˆ‘ä»¬ä½¿ç”¨å“ˆå¸Œè¡¨å­˜å‚¨æ¯ä¸€ä¸ªé‚®ç®±çš„è´¦æˆ·ç¼–å·ï¼Œæœ€åè¿›è¡Œé›†åˆåˆå¹¶å³å¯ç»´æŠ¤å¥½æ¯ä¸€ä¸ªè´¦å·å½’å±çš„é›†åˆç¼–å·ã€‚$O(nm)$
> - å¦‚ä½•åˆå¹¶æŒ‡å®šè´¦æˆ·ï¼Ÿå¯¹äºä¸Šè¿°ç»´æŠ¤å¥½çš„é›†åˆç¼–å·ï¼Œæˆ‘ä»¬éœ€è¦åˆå¹¶æ‰€æœ‰å«æœ‰ç›¸åŒâ€œç¥–å…ˆâ€çš„è´¦æˆ·ã€‚æ’åºå»é‡æˆ–ä½¿ç”¨æœ‰åºåˆ—è¡¨å‡å¯å®ç°ã€‚$O(n\log n)$
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n\log n)$

```cpp
struct dsu {
    int n;
    std::vector<int> p;
    dsu(int _n) { n = _n; p.resize(n + 1); for (int i = 1; i <= n; i++) p[i] = i; }
    int find(int x) { return (p[x] == x ? p[x] : p[x] = find(p[x])); }
    void merge(int a, int b) { p[find(a)] = find(b); }
    bool query(int a, int b) { return find(a) == find(b); }
    int block() { int ret = 0; for (int i = 1; i <= n; i++) ret += p[i] == i; return ret; }
};

class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
        // ç»´æŠ¤æ¯ä¸€ä¸ªå­è´¦æˆ·å½’å±çš„é›†åˆ
        int n = accounts.size();
        unordered_map<string, vector<int>> hash;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j < accounts[i - 1].size(); j++) {
                hash[accounts[i - 1][j]].push_back(i);
            }
        }        
        dsu d(n);
        for (auto& it: hash) {
            vector<int> v = it.second;
            for (int i = 1; i < v.size(); i++) {
                d.merge(v[i - 1], v[i]);
            }
        }

        // æŒ‰ç…§å­è´¦æˆ·å½’å±çš„é›†åˆåˆå¹¶å‡ºæœ€ç»ˆçš„è´¦æˆ·
        unordered_set<int> fa;
        for (int i = 1; i <= n; i++) {
            fa.insert(d.find(i));
        }
        vector<vector<string>> res;
        for (auto p: fa) {
            set<string> se;
            vector<string> ans;
            for (int i = 1; i <= n; i++) {
                if (d.find(i) == p) {
                    if (ans.empty()) {
                        ans.push_back(accounts[i - 1][0]);
                    }
                    for (int j = 1; j < accounts[i - 1].size(); j++) {
                        se.insert(accounts[i - 1][j]);
                    }
                }
            }
            for (auto mail: se) {
                ans.push_back(mail);
            }
            res.push_back(ans);
        }

        return res;
    }
};
```

```python
class dsu:
    def __init__(self, n: int) -> None:
        self.n = n
        self.p = [i for i in range(n + 1)]
    def find(self, x: int) -> int:
        if self.p[x] != x: self.p[x] = self.find(self.p[x])
        return self.p[x]
    def merge(self, a: int, b: int) -> None:
        self.p[self.find(a)] = self.find(b)
    def query(self, a: int, b: int) -> bool:
        return self.find(a) == self.find(b)
    def block(self) -> int:
        return sum([1 for i in range(1, self.n + 1) if self.p[i] == i])

class Solution:
    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
        from collections import defaultdict
        
        n = len(accounts)
        hash = defaultdict(list)
        for i in range(1, n + 1):
            for j in range(1, len(accounts[i - 1])):
                hash[accounts[i - 1][j]].append(i)
        
        d = dsu(n)
        for _, ids in hash.items():
            for i in range(1, len(ids)):
                d.merge(ids[i - 1], ids[i])
        
        fa = set()
        for i in range(1, n + 1):
            fa.add(d.find(i))
        
        res = []
        for p in fa:
            ans = []
            se = set()
            for i in range(1, n + 1):
                if d.find(i) == p:
                    if len(ans) == 0:
                        ans.append(accounts[i - 1][0])
                    for j in range(1, len(accounts[i - 1])):
                        se.add(accounts[i - 1][j])
            ans += sorted(se)
            res.append(ans)
        
        return res
```

## ã€æ ‘çŠ¶æ•°ç»„ã€‘å°†å…ƒç´ åˆ†é…åˆ°ä¸¤ä¸ªæ•°ç»„ä¸­ II

<https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii/description/>

> é¢˜æ„ï¼šç»™å®š $n$ ä¸ªæ•°ï¼Œç°åœ¨éœ€è¦å°†è¿™äº›æ•°æŒ‰ç…§æŸç§è§„åˆ™åˆ†é…åˆ°ä¸¤ä¸ªæ•°ç»„ $A$ å’Œ $B$ ä¸­ã€‚åˆå§‹åŒ–åˆ†é… `nums[0]` åˆ° $A$ ä¸­ï¼Œ`nums[1]` åˆ° $B$ ä¸­ï¼Œæ¥ä¸‹æ¥å¯¹äºå‰©ä½™çš„æ¯ä¸ªå…ƒç´  `nums[i]`ï¼Œåˆ†é…å–å†³äº $A$ å’Œ $B$ ä¸­æ¯”å½“å‰å…ƒç´  `nums[i]` å¤§çš„ä¸ªæ•°ï¼Œæœ€ç»ˆè¿”å›ä¸¤ä¸ªåˆ†é…å¥½çš„æ•°ç»„
>
> æ€è·¯ï¼šé¦–å…ˆæ¯ä¸€ä¸ªå…ƒç´ éƒ½éœ€è¦è¿›è¡Œæšä¸¾ï¼Œé‚£ä¹ˆæœ¬é¢˜éœ€è¦è€ƒè™‘çš„å°±æ˜¯å¦‚ä½•åœ¨ $\log$ æ—¶é—´å¤æ‚åº¦å†…ç»Ÿè®¡å‡ºä¸¤æ•°ç»„ä¸­æ¯”å½“å‰å…ƒç´ å¤§çš„å…ƒç´ ä¸ªæ•°ã€‚é’ˆå¯¹ C++ å’Œ Python åˆ†åˆ«è®¨è®º
>
> - C++
>     - æ³•ä¸€ï¼š`std::multiset<int>`ã€‚å¯æƒœä¸è¡Œï¼Œå› ä¸ºç»Ÿè®¡æ¯”å½“å‰å…ƒç´ å¤§çš„ä¸ªæ•°æ—¶ï¼Œ`s.rbegin() - s.upper_bound(nums[i])` æ˜¯ä¸åˆæ³•çš„ï¼Œå› ä¸º `std::multiset<int>` çš„è¿­ä»£å™¨ä¸æ˜¯åŸºäºæŒ‡é’ˆçš„ï¼Œå› æ­¤æ— æ³•ç›´æ¥è¿›è¡ŒåŠ å‡æ¥è®¡ç®—åœ°å€å·®ï¼Œé‚ä½œç½¢
>     - æ³•äºŒï¼šæ ‘çŠ¶æ•°ç»„ã€‚å¾ˆå®¹æ˜“æƒ³åˆ°åˆ©ç”¨å‰ç¼€å’Œç»Ÿè®¡æ¯”å½“å‰æ•°å¤§çš„æ•°å­—ä¸ªæ•°ï¼Œä½†æ˜¯ç”±äºæ­¤å¤„éœ€è¦å¯¹å‰ç¼€å’Œè¿›è¡Œå•ç‚¹ä¿®æ”¹ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦è‚¯å®šä¼šå¯„ã€‚æœ‰ä»€ä¹ˆæ•°æ®ç»“æ„æ”¯æŒã€Œå•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æ›´æ–°ã€å‘¢ï¼Ÿæˆ‘ä»¬å¼•å…¥æ ‘çŠ¶æ•°ç»„ã€‚æˆ‘ä»¬å°†æ•°ç»„å…ƒç´ å“ˆå¸Œåˆ° `[1, len(set(nums))]` åŒºé—´ï¼Œå®šä¹‰å“ˆå¸Œåçš„å½“å‰å…ƒç´  `nums[i]` ä¸º `x`ï¼Œå¯¹äºå½“å‰å“ˆå¸Œåçš„ `x` è€Œè¨€æƒ³è¦çŸ¥é“ä¸¤ä¸ªæ•°ç»„ä¸­æœ‰å¤šå°‘æ•°æ¯”å½“å‰æ•°ä¸¥æ ¼å¤§ï¼Œåªéœ€è¦è®¡ç®—å‰ç¼€å’Œæ•°ç»„ `arr` ä¸­ `arr[n] - arr[x]` çš„ç»“æœå³å¯
> - Python
>     - `SortedList`ã€‚python æœ‰ä¸€ä¸ª `sortedcontainers` åŒ…å…¶ä¸­æœ‰ `SortedList` æ¨¡å—ï¼Œå¯ä»¥å®ç° `std::multiset<int>` æ‰€æœ‰ $\log$ æ“ä½œå¹¶ä¸”å¯ä»¥è¿›è¡Œéšæœºä¸‹æ ‡è®¿é—®ï¼Œäºæ˜¯å°±å¯ä»¥è¿›è¡Œä¸‹æ ‡è®¿é—® $O(1)$ è®¡ç®—æ¯”å½“å‰æ•°å¤§çš„å…ƒç´ ä¸ªæ•°
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n \log n)$

```cpp
template<class T>
class BinaryIndexedTree {
private:
    std::vector<T> _arr;
    int _n;

    int lowbit(int x) { return x & (-x); }

public:
    BinaryIndexedTree(int n) :_n(n) {
        _arr.resize(_n + 1, 0);
    }

    void add(int pos, T x) {
        while (pos <= _n) {
            _arr[pos] += x;
            pos += lowbit(pos);
        }
    }

    T sum(int pos) {
        T ret = 0;
        while (pos) {
            ret += _arr[pos];
            pos -= lowbit(pos);
        }
        return ret;
    }
};


class Solution {
public:
    vector<int> resultArray(vector<int>& nums) {
        vector<int> copy = nums;
        sort(copy.begin(), copy.end());
        copy.erase(unique(copy.begin(), copy.end()), copy.end());

        int n = copy.size(), cnt = 1;
        unordered_map<int, int> a;
        for (int i = 0; i < n; i++) {
            a[copy[i]] = cnt++;
        }

        vector<int> v1, v2;
        v1.push_back(nums[0]);
        v2.push_back(nums[1]);

        BinaryIndexedTree<int> t1(n), t2(n);
        t1.add(a[nums[0]], 1);
        t2.add(a[nums[1]], 1);

        for (int i = 2; i < nums.size(); i++) {
            int d1 = t1.sum(n) - t1.sum(a[nums[i]]);
            int d2 = t2.sum(n) - t2.sum(a[nums[i]]);

            if (d1 > d2) {
                v1.push_back(nums[i]);
                t1.add(a[nums[i]], 1);                
            } else if (d1 < d2) {
                v2.push_back(nums[i]);
                t2.add(a[nums[i]], 1);
            } else if (d1 == d2 && v1.size() < v2.size()) {
                v1.push_back(nums[i]);
                t1.add(a[nums[i]], 1);
            } else if (d1 == d2 && v1.size() > v2.size()) {
                v2.push_back(nums[i]);
                t2.add(a[nums[i]], 1);
            } else {
                v1.push_back(nums[i]);
                t1.add(a[nums[i]], 1);
            }
        }

        for (int x: v2) {
            v1.push_back(x);
        }

        return v1;
    }
};
```

```python
class BinaryIndexedTree:
    def __init__(self, n: int):
        self._n = n
        self._arr = [0] * (n + 1)

    def _lowbit(self, x: int) -> int:
        return x & (-x)

    def add(self, pos: int, x: int) -> None:
        while pos <= self._n:
            self._arr[pos] += x
            pos += self._lowbit(pos)

    def sum(self, pos: int) -> int:
        ret = 0
        while pos:
            ret += self._arr[pos]
            pos -= self._lowbit(pos)
        return ret


class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        copy = sorted(set(nums))
        
        n, cnt, a = len(copy), 1, {}
        for x in copy:
            a[x] = cnt
            cnt += 1

        v1, v2 = [nums[0]], [nums[1]]
        t1, t2 = BinaryIndexedTree(n), BinaryIndexedTree(n)
        t1.add(a[nums[0]], 1)
        t2.add(a[nums[1]], 1)
        
        for x in nums[2:]:
            d1, d2 = t1.sum(n) - t1.sum(a[x]), t2.sum(n) - t2.sum(a[x])
            
            if d1 > d2:
                v1.append(x)
                t1.add(a[x], 1)
            elif d1 < d2:
                v2.append(x)
                t2.add(a[x], 1)
            elif d1 == d2 and len(v1) < len(v2):
                v1.append(x)
                t1.add(a[x], 1)
            elif d1 == d2 and len(v1) > len(v2):
                v2.append(x)
                t2.add(a[x], 1)
            else:
                v1.append(x)
                t1.add(a[x], 1)
        
        return v1 + v2
```

```python
class Solution:
    def resultArray(self, nums: List[int]) -> List[int]:
        from sortedcontainers import SortedList
        
        v1, v2 = copy.deepcopy(nums[:1]), copy.deepcopy(nums[1:2])
        s1, s2 = SortedList(v1), SortedList(v2)

        for x in nums[2:]:
            d1, d2 = len(v1) - s1.bisect_right(x), len(v2) - s2.bisect_right(x)
            
            if d1 > d2:
                v1.append(x)
                s1.add(x)
            elif d1 < d2:
                v2.append(x)
                s2.add(x)
            elif d1 == d2 and len(v1) < len(v2):
                v1.append(x)
                s1.add(x)
            elif d1 == d2 and len(v1) > len(v2):
                v2.append(x)
                s2.add(x)
            else:
                v1.append(x)
                s1.add(x)
        
        return v1 + v2
```

## ã€çº¿æ®µæ ‘ã€‘ä»¥ç»„ä¸ºå•ä½è®¢éŸ³ä¹ä¼šçš„é—¨ç¥¨ğŸ˜­

<https://leetcode.cn/problems/booking-concert-tickets-in-groups/>

> é¢˜æ„ï¼šç»™å®šä¸€ä¸ªé•¿ä¸º $n\le 5 \times 10^4$ ä¸”åˆå§‹å€¼å‡ä¸º $0$ çš„æ•°ç»„ $a$ï¼Œæ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æœ€å¤šå¢åŠ åˆ° $m$ã€‚ç°åœ¨éœ€è¦ä»¥è¿™ä¸ªæ•°ç»„ä¸ºåŸºç¡€è¿›è¡Œ $q\le 5 \times 10^4$ æ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®æ˜¯ä»¥ä¸‹ä¸¤è€…ä¹‹ä¸€ï¼š
>
> 1. ç»™å®šä¸€ä¸ª $k$ å’Œ $lim$ï¼Œæ‰¾åˆ°æœ€å°çš„ $i \in [0,lim]$ ä½¿å¾— $m - a_i \ge k$
> 2. ç»™å®šä¸€ä¸ª $k$ å’Œ $lim$ï¼Œæ‰¾åˆ°æœ€å°çš„ $i \in [0,lim]$ ä½¿å¾— $\displaystyle m\times (i+1) - \sum_{j=0}^i a_j \ge k$
>
> æ€è·¯ä¸€ï¼š**æš´åŠ›**ã€‚
>
> - å¯¹äºè¯¢é—® 1ï¼Œæˆ‘ä»¬ç›´æ¥é¡ºåºéå† a æ•°ç»„ç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å³å¯ï¼›å¯¹äºè¯¢é—® 2ï¼ŒåŒæ ·ç›´æ¥é¡ºåºéå† a æ•°ç»„ç›´åˆ°æ‰¾åˆ°ç¬¬ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å³å¯ï¼›
> - æ—¶é—´å¤æ‚åº¦ $O(qn)$ã€‚
>
> æ€è·¯äºŒï¼š**çº¿æ®µæ ‘ä¸ŠäºŒåˆ†**ã€‚
>
> - TODO
> - æ—¶é—´å¤æ‚åº¦ $O(q\log n)$ã€‚

æš´åŠ›ä»£ç ï¼š

```python
class BookMyShow:

    def __init__(self, n: int, m: int):
        self.a = [0] * n  # a[i] è¡¨ç¤ºç¬¬ i è¡Œå·²å…¥åº§çš„äººæ•°
        self.n = n
        self.m = m

    def gather(self, k: int, lim: int) -> List[int]:
        # åœ¨ [0, lim] è¡Œä¸­æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¯ä»¥å®¹çº³ k äººçš„è¡Œ
        for i in range(lim + 1):
            if self.m - self.a[i] >= k:
                l, r = i, self.a[i]
                self.a[i] += k
                return [l, r]
        return []

    def scatter(self, k: int, lim: int) -> bool:
        # åœ¨ [0, lim] è¡Œä¸­æ‰¾åˆ°æœ€å°çš„ i ä½¿å¾— [0, i] è¡Œå¯ä»¥å®¹çº³ k äºº
        if self.m * (lim + 1) - sum(self.a[:lim+1]) < k:
            return False

        i = 0
        while k > 0:
            if self.m - self.a[i] >= k:
                self.a[i] += k
                k = 0
            else:
                k -= self.m - self.a[i]
                self.a[i] = self.m
            i += 1
        return True
```

çº¿æ®µæ ‘ä¸ŠäºŒåˆ†ä»£ç ï¼š

```python

```

## ã€å“ˆå¸Œã€‘åˆ†ç»„

<https://www.acwing.com/problem/content/5182/>

> å­˜å‚¨ä¸æƒ³åŒç»„å’Œæƒ³åŒç»„çš„äººå‘˜ä¿¡æ¯ï¼šå­˜å…¥æ•°ç»„ï¼Œæ•°æ®ç±»å‹ä¸ºä¸€å¯¹å­—ç¬¦ä¸²
>
> å­˜å‚¨æ‰€æœ‰çš„ç»„é˜Ÿä¿¡æ¯ï¼šå­˜å…¥å“ˆå¸Œè¡¨ï¼Œæ•°æ®ç±»å‹ä¸ºâ€œé”®:å­—ç¬¦ä¸²â€â€œå€¼:ä¸€å¯¹å­—ç¬¦ä¸²â€
>
> æƒ³è¦çŸ¥é“æœ€ç»ˆçš„åˆ†ç»„æƒ…å†µï¼Œåªéœ€è¦æŸ¥è¯¢æ•°ç»„ä¸­çš„é˜Ÿå‘˜æƒ…å†µä¸æƒ³åŒç»„ or ä¸æƒ³åŒç»„çš„æˆå‘˜åå­—æ˜¯å¦ä¸€è‡´å³å¯
>
> æ—¶é—´å¤æ‚åº¦ $O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(n\ len(name))_{max}$

```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
using namespace std;

int main()
{
    int x;
    cin >> x;
    
    vector<pair<string, string>> X(x);
    
    for (int i = 0; i < x; i ++)
        cin >> X[i].first >> X[i].second;
    
    int y;
    cin >> y;
    
    vector<pair<string, string>> Y(y);
    
    for (int i = 0; i < y; i ++)
        cin >> Y[i].first >> Y[i].second;
        
    int sum;
    cin >> sum;
    
    unordered_map<string, pair<string, string>> a;
    
    for (int i = 0; i < sum; i ++)
    {
        string s, t, p;
        cin >> s >> t >> p;
        a[s] = {t, p};
        a[t] = {s, p};
        a[p] = {s, t};
    }
    
    int res = 0;
    
    // æƒ³åŒç»„ 
    for (int i = 0; i < x; i ++)
    {
        string s = X[i].first, t = X[i].second;
        if (a[s].first != t && a[s].second != t)
            res ++;
    }
    
    // ä¸æƒ³åŒç»„ 
    for (int i = 0; i < y; i ++)
    {
        string s = Y[i].first, t = Y[i].second;
        if (a[s].first == t || a[s].second == t)
            res ++; 
    }
    
    cout << res << endl; 
    
    return 0;
}
```

## ã€å“ˆå¸Œã€‘æµ·æ¸¯

<https://www.luogu.com.cn/problem/P2058>

> - é¢˜æ„ï¼šç»™å®š n è‰˜èˆ¹åªçš„åˆ°è¾¾æ—¶é—´ã€è½½å®¢ä¿¡æ¯ï¼ˆè½½å®¢äººæ•°å’Œæ¯ä¸€ä¸ªå®¢äººçš„å›½ç±ï¼‰ï¼Œç°åœ¨éœ€è¦çŸ¥é“å¯¹äºæ¯ä¸€è‰˜æŠµè¾¾çš„èˆ¹åªï¼Œå‰ 24 å°æ—¶ä¸­æŠµè¾¾çš„å®¢äººçš„å›½ç±æ€»æ•°
> - æ€è·¯ï¼šæœ¬é¢˜æ€è·¯å¾ˆç®€å•ï¼Œå°±æ˜¯ä¸€ä¸ªé˜Ÿåˆ—çš„åº”ç”¨ä»¥åŠå“ˆå¸Œå®¢äººå›½ç±çš„è¿‡ç¨‹ã€‚ç”±äºèˆ¹åªæŠµè¾¾çš„æ—¶é—´æ˜¯é¡ºåºå¢åŠ çš„ï¼Œæ•…æ¯æŠµè¾¾ä¸€è‰˜èˆ¹åªï¼Œå°±å¯¹æ–°æ¥çš„å®¢äººå›½ç±è¿›è¡Œå“ˆå¸Œï¼Œä¸ºäº†è®¡ç®—å‰ 24 å°æ—¶çš„æƒ…å†µï¼Œéœ€è¦å¯¹èˆ¹åªæŠµè¾¾é˜Ÿåˆ—è¿›è¡Œåˆ å‡ï¼Œå³åªä¿ç•™ 24 å°æ—¶ä»¥å†…çš„èˆ¹åªæŠµè¾¾ä¿¡æ¯ã€‚å¯¹äºåˆ é™¤çš„èˆ¹åªä¿¡æ¯ï¼Œéœ€è¦å°†è¿™äº›èˆ¹åªä¸Šçš„å®¢äººå›½ç±ä¿¡æ¯ä»å“ˆå¸Œè¡¨ä¸­åˆ é™¤ï¼Œæ•…æ¯ä¸€è‰˜èˆ¹åªçš„è®¿é—®æ¬¡æ•°ä¸º 2ã€‚
> - `unordered_map `è¡¥å……ï¼šåœ¨è¿›è¡Œå“ˆå¸Œç»Ÿè®¡æ—¶ã€‚ä¸ºäº†åˆ¤æ–­å½“å‰ 24 å°æ—¶å†…å®¢äººå›½ç±æ•°ï¼Œåœ¨åˆ é™¤å“ˆå¸Œè®°å½•æ—¶ï¼Œä¸ºäº†åˆ¤æ–­æ˜¯å¦å°†å½“å‰å›½ç±çš„æ¸¸å®¢å…¨éƒ¨åˆ é™¤æ—¶ï¼Œéœ€è¦ç»Ÿè®¡å“ˆå¸Œè¡¨ä¸­æŸä¸ªå›½ç±æ˜¯å¦å‡ä¸ºäº† 0ï¼Œæˆ‘ç”¨äº† `.count(x)` å†…ç½®æ–¹æ³•ï¼Œä½†è¿™æ˜¯ä¸æ­£ç¡®çš„ï¼Œå› ä¸ºæˆ‘æƒ³è¦ç»Ÿè®¡çš„æ˜¯ å€¼ æ˜¯å¦ä¸º 0ï¼Œè€Œ `.count(x)` ç»Ÿè®¡çš„æ˜¯å“ˆå¸Œè¡¨ä¸­ x è¿™ä¸ª é”® çš„ä¸ªæ•°ï¼Œè€Œ `unordered_map `ä¸­æ˜¯æ²¡æœ‰é‡å¤çš„é”®çš„ï¼Œæ•… `.count(x)` æ–¹æ³•åªä¼šè¿”å› 0 æˆ– 1ï¼Œè¿”å› 0 å°±è¡¨ç¤ºå½“å‰å“ˆå¸Œè¡¨ä¸­æ²¡æœ‰ x è¿™ä¸ªé”®ï¼Œè¿”å› 1 å°±è¡¨ç¤ºå“ˆå¸Œè¡¨ä¸­æœ‰ x è¿™ä¸ªé”®ï¼Œä½†æ˜¯æœ‰è¿™ä¸ªé”®ä¸ä»£è¡¨å¯¹åº”çš„å€¼å°±å­˜åœ¨ï¼Œå¯èƒ½æ˜¯ `x: 0` çš„æƒ…å†µï¼Œå³é”®å­˜åœ¨ï¼Œä½†æ˜¯å€¼è®°å½•ä¸º 0
> - æ—¶é—´å¤æ‚åº¦ï¼š$O(2 \sum x_i)$ - å³ä¸¤å€çš„æ‰€æœ‰æ¸¸å®¢æ•°

```cpp
// #include <bits/stdc++.h>
// #define int long long
#include <iostream>
#include <unordered_map>
#include <stack>
#include <queue>
using namespace std;

const int N = 1e5 + 10;

struct Ship { int idx, t; };

int n;
queue<Ship> q;
vector<int> G[N];
unordered_map<int, int> cnt;
int kind;

void solve() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        int t, num;
        cin >> t >> num;
        
        q.push({i, t});
        
        // å“ˆå¸Œ
        while (num--) {
            int id;
            cin >> id;
            
            if (!cnt[id]) kind++;
            cnt[id]++;
            G[i].push_back(id);
        }
        
        // å»å“ˆå¸Œ
        Ship h = q.front();
        while (t - h.t >= 86400) {
            for (auto& id: G[h.idx]) {
                cnt[id]--;
                if (!cnt[id]) kind--;
            }
            q.pop();
            h = q.front();
        }
        
        cout << kind << "\n";
    }
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€å“ˆå¸Œã€‘Cities and States S

<https://www.luogu.com.cn/problem/P3405>

> é¢˜æ„ï¼šç»™å®š n ä¸ªå­—ç¬¦ä¸²ï¼Œæ¯ä¸€ä¸ªå­—ç¬¦ä¸²å½’å±ä¸€ä¸ªé›†åˆï¼Œç°åœ¨éœ€è¦ç»Ÿè®¡å­—ç¬¦ä¸²ä¸é›†åˆåç›¸åç›¸ç­‰çš„å¯¹æ•°
>
> æ€è·¯ï¼šå¾ˆæ˜¾ç„¶çš„å“ˆå¸Œè®¡æ•°ã€‚éš¾ç‚¹æœ‰ä¸¤ä¸ªï¼Œå¦‚ä½•å“ˆå¸Œï¼Ÿå¦‚ä½•è®¡æ•°ï¼Ÿå“ˆå¸Œå¯ä»¥é‡‡ç”¨æ‰©å±•å­—ç¬¦çš„æ–¹æ³•è¿›è¡Œï¼Œå³ç¬¬ä¸€ä¸ªå­—ç¬¦ä¹˜æŸä¸€ä¸ªè¾ƒå¤§çš„è´¨æ•°å†åŠ ä¸Šç¬¬äºŒä¸ªå­—ç¬¦ã€‚æ­¤å¤„é‡‡ç”¨ä¸€ç§è¾ƒä¸ºå·§å¦™çš„æ–¹æ³•ï¼Œç›´æ¥å°†ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸é›†åˆååŠ èµ·æ¥è¿›è¡Œå”¯ä¸€æ€§å“ˆå¸Œï¼Œé™ä½ç¼–ç éš¾åº¦ã€‚è®¡æ•°æœ‰ä¸¤ç§æ–¹å¼ï¼Œç¬¬ä¸€ç§å°±æ˜¯å…¨éƒ¨å“ˆå¸Œç»“æŸä¹‹åï¼Œå†éå†å“ˆå¸Œè¡¨è¿›è¡Œç»Ÿè®¡ï¼Œæœ€åå°†ç»“æœé™¤äºŒå³å¯ã€‚ç¬¬äºŒç§å°±æ˜¯è¾¹å“ˆå¸Œè¾¹è®¡æ•°ï¼Œé‡åˆ°ç›¸åç›¸ç­‰çš„å°±ç›´æ¥è®¡æ•°ï¼Œè¿™æ ·å°±ä¸ä¼šé‡å¤è®¡æ•°äº†ï¼Œä¹Ÿå¾ˆå·§å¦™
>
> æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$

```cpp
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <stack>
#include <queue>
#include <set>
using namespace std;

int n;
unordered_map<string, int> a;

void solve() {
    cin >> n;
    
    int res = 0;
    
    while (n--) {
        string s, t;
        cin >> s >> t;
        s = s.substr(0, 2);
        res += a[t + " " + s] * (s != t);
        a[s + " " + t]++;
    }
    
    cout << res << "\n";
}

signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr), cout.tie(nullptr);
    int T = 1;
//    cin >> T;
    while (T--) solve();
    return 0;
}
```

## ã€å“ˆå¸Œã€‘Torn Lucky Ticket

<https://codeforces.com/contest/1895/problem/C>

> é¢˜æ„: ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º n çš„å­—ç¬¦ä¸²æ•°ç»„ nums, æ•°ç»„çš„æ¯ä¸€ä¸ªå…ƒç´ é•¿åº¦ä¸è¶…è¿‡ 5 ä¸”ä»…ç”±æ•°å­—ç»„æˆ. é—®èƒ½æ‰¾åˆ°å¤šå°‘å¯¹ $(i,j)$ å¯ä»¥ä½¿å¾—æ‹¼æ¥åçš„ $nums[i]+nums[j]$ é•¿åº¦ä¸ºå¶æ•°ä¸”å·¦åŠéƒ¨åˆ†çš„æ•°å­—ä¹‹å’Œä¸å³åŠéƒ¨åˆ†çš„æ•°å­—ä¹‹å’Œç›¸ç­‰.
>
> æ€è·¯: 
>
> - é¦–å…ˆæœ€æš´åŠ›çš„åšæ³•å°±æ˜¯ $O(n^2)$ æšä¸¾,æ‰€æœ‰çš„ $(i,j)$ ç„¶å check åˆæ³•æ€§.
>
> - å°è¯•ä¼˜åŒ–æ‰ç¬¬äºŒå±‚çš„æšä¸¾å¾ªç¯. å¯¹äºç¬¬äºŒå±‚å¾ªç¯, æˆ‘ä»¬å°±æ˜¯è¦å¯»æ‰¾åˆé€‚çš„ $nums[j]$ å¹¶å’Œå½“å‰çš„ $nums[i]$ æ‹¼æ¥. æ˜¾ç„¶æˆ‘ä»¬å¯ä»¥é€šè¿‡æ‰«æå½“å‰çš„ $nums[i]$ å¹¶ $O(1)$ çš„è®¡ç®—å‡ºæ‰€æœ‰ $len(nums[j])\le len(nums[i])$ ä¸”å¯ä»¥å’Œ $nums[i]$ åŒ¹é…çš„å­—ç¬¦ä¸²çš„ `[é•¿åº¦][æ•°å­—å’Œ]` ä¿¡æ¯, åªéœ€è¦ä¸€ä¸ªäºŒç»´æ•°ç»„é¢„å­˜å‚¨æ¯ä¸€ä¸ªå­—ç¬¦ä¸²çš„ **é•¿åº¦** **æ•°å­—å’Œ** ä¿¡æ¯å³å¯.
>
> - é‚£ä¹ˆå¯¹äº $len(nums[j])> len(nums[i])$ çš„æƒ…å†µå¦‚ä½•ç»Ÿè®¡å‘¢. æ˜¾ç„¶æ­¤æ—¶æˆ‘ä»¬æ²¡æ³• $O(1)$ çš„æ£€æŸ¥ $nums[i]+nums[j]$ çš„åˆæ³•æ€§. ä¸å¦¨æ¢ä¸€ä¸ªè§’åº¦, å½“æˆ‘ä»¬æšä¸¾ $nums[i]$ æ—¶:
>
>     $$
>     \text{ç»Ÿè®¡å³ä¾§æ‹¼æ¥é•¿åº¦æ›´å¤§çš„ nums[j] çš„åˆæ³•æƒ…å†µæ•°} \iff \text{ç»Ÿè®¡å·¦ä¾§æ‹¼æ¥é•¿åº¦æ›´å°çš„ nums[j] çš„åˆæ³•æƒ…å†µæ•°}
>     $$
>
>     äºæ˜¯åˆæ³•æƒ…å†µæ•°å°±å¯ä»¥è¡¨ç¤ºä¸º
>     
>     $$
>     \sum_{i=0}^{n-1}\big[\text{cond}_1(nums[i])+\text{cond}_2(nums[i])\big]
>     $$
>     
>     å…¶ä¸­ç¬¬ä¸€ç§æƒ…å†µ $\text{cond}_1$ å°±æ˜¯ç»Ÿè®¡å³ä¾§æ‹¼æ¥é•¿åº¦æ›´å°çš„å­—ç¬¦ä¸²æ•°é‡, ç¬¬äºŒç§æƒ…å†µ $\text{cond}_1$ å°±æ˜¯ç»Ÿè®¡å·¦ä¾§æ‹¼æ¥é•¿åº¦æ›´å°çš„å­—ç¬¦ä¸²æ•°é‡. è¿™ä¸¤æ­¥å¯ä»¥åŒæ—¶è®¡ç®—.
>
> æ—¶é—´å¤æ‚åº¦: $O(n)$

```python
from typing import List, Tuple, Dict, Optional
from collections import defaultdict, deque
from itertools import combinations, permutations
import math, heapq, queue

II = lambda: int(input())
FI = lambda: float(input())
MII = lambda: tuple(map(int, input().split()))
LII = lambda: list(map(int, input().split()))
LSI = lambda: list(map(str, input().split()))

def solve() -> Optional:
    n, nums = II(), LSI()
    
    f = [[0 for _ in range(46)] for _ in range(6)]
    for num in nums:
        m = len(num)
        s = sum([int(c) for c in num])
        f[m][s] += 1
    
    res = 0
    for num in nums:
        m = len(num)
        s = [0] * (m + 1)
        for i in range(m - 1, -1, -1):
            s[i] = s[i + 1] + int(num[i])
        
        # cond1: now + right -> len(now) >= len(right)
        for i in range(m - 1, -1, -1):
            now_len, now_sum = i + 1, s[0] - s[i + 1]
            r_len, r_sum = now_len - (m - 1 - i), now_sum - s[i + 1]
            if 1 <= r_len <= now_len and r_sum >= 0:
                res += f[r_len][r_sum]
        
        # cond2: left + now -> len(left) < len(now)
        for i in range(m):
            now_len, now_sum = m - i, s[i]
            l_len, l_sum = now_len - i, now_sum - (s[0] - s[i])
            if 1 <= l_len < now_len and l_sum >= 0:
                res += f[l_len][l_sum]
    
    return res

if __name__ == '__main__':
    OUTs = []
    N = 1
    # N = II()
    for _ in range(N):
        OUTs.append(solve())
    print('\n'.join(map(str, OUTs)))
```
